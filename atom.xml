<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leila&#39;s blog</title>
  
  <subtitle>Goals determine what you are going to be</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://LeilaBlog.site/"/>
  <updated>2018-05-01T09:26:24.647Z</updated>
  <id>http://LeilaBlog.site/</id>
  
  <author>
    <name>zhangxiaolei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>博客迁移</title>
    <link href="http://LeilaBlog.site/2018/05/01/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB/"/>
    <id>http://LeilaBlog.site/2018/05/01/博客迁移/</id>
    <published>2018-05-01T09:18:17.000Z</published>
    <updated>2018-05-01T09:26:24.647Z</updated>
    
    <content type="html"><![CDATA[<p>(<em>^__^</em>) 嘻嘻……今天把这个博客迁移仓库啦 哈哈哈 开心O(∩_∩)O~~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;(&lt;em&gt;^__^&lt;/em&gt;) 嘻嘻……今天把这个博客迁移仓库啦 哈哈哈 开心O(∩_∩)O~~&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://LeilaBlog.site/2018/05/01/hello-world/"/>
    <id>http://LeilaBlog.site/2018/05/01/hello-world/</id>
    <published>2018-05-01T09:04:13.231Z</published>
    <updated>2017-05-26T03:15:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>关于弹出层居中</title>
    <link href="http://LeilaBlog.site/2018/04/08/%E5%85%B3%E4%BA%8E%E5%BC%B9%E5%87%BA%E5%B1%82%E5%B1%85%E4%B8%AD/"/>
    <id>http://LeilaBlog.site/2018/04/08/关于弹出层居中/</id>
    <published>2018-04-08T08:12:22.000Z</published>
    <updated>2018-04-08T09:56:22.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><p>html<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 遮罩层 --&gt;</span><br><span class="line">&lt;div class=&quot;mask&quot;&gt;</span><br><span class="line">&lt;!-- 弹出框 --&gt;</span><br><span class="line">    &lt;div class=&quot;tips&quot;&gt;</span><br><span class="line">         &lt;h6 id=&quot;tishi&quot;&gt;&lt;/h6&gt;</span><br><span class="line">         &lt;i class=&quot;close&quot;&gt;&lt;/i&gt;</span><br><span class="line">         &lt;span&gt;提交&lt;/span&gt;</span><br><span class="line">         &lt;span&gt;重置&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>css<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">.mask&#123;</span><br><span class="line">position:absolute;</span><br><span class="line">top:0;</span><br><span class="line">left:0;</span><br><span class="line">background:rgba(0,0,0,0.7);</span><br><span class="line">width:100%;</span><br><span class="line">height:100%;</span><br><span class="line">&#125;</span><br><span class="line">.mask .tips&#123;</span><br><span class="line">width:200px;</span><br><span class="line">height:300px;</span><br><span class="line">background:#fff;</span><br><span class="line">position:absolute;</span><br><span class="line">top:0;</span><br><span class="line">bottom:0;</span><br><span class="line">left:0;</span><br><span class="line">bottom:0;</span><br><span class="line">margin:auto;</span><br><span class="line">text-align:center;</span><br><span class="line">&#125;</span><br><span class="line">.mask .tips:hover #close::after&#123;</span><br><span class="line">opacity:1;</span><br><span class="line">transform:none;</span><br><span class="line">&#125;</span><br><span class="line">.mask .tips #close::after&#123;</span><br><span class="line">opacity:0;</span><br><span class="line">transform:scale(0.8,0.8);</span><br><span class="line">transition:transform 0.6s ease,opacity 0.6s ease;</span><br><span class="line">content:&apos;X&apos;;</span><br><span class="line">border-radius:50%;</span><br><span class="line">width:30px;</span><br><span class="line">height:30px;</span><br><span class="line">position:absolute;</span><br><span class="line">right:-15px;</span><br><span class="line">top:-15px;</span><br><span class="line">backgrounhd:#000;</span><br><span class="line">color:#fff;</span><br><span class="line">text-align:center;</span><br><span class="line">line-height:30px;</span><br><span class="line">font-family:&apos;consolas&apos;;</span><br><span class="line">&#125;</span><br><span class="line">.mask .tips span&#123;</span><br><span class="line">cursor:pointer;</span><br><span class="line">margin-top:130px;</span><br><span class="line">display:inline-block;</span><br><span class="line">padding:10px 30px;</span><br><span class="line">background:#eco9ee;</span><br><span class="line">color:#fff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="水平垂直居中-1"><a href="#水平垂直居中-1" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><p>第一种<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#container&#123;</span><br><span class="line">    position:relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#center&#123;</span><br><span class="line">    width:100px;</span><br><span class="line">    height:100px;</span><br><span class="line">    position:absolute;</span><br><span class="line">    top:50%;</span><br><span class="line">    left:50%;</span><br><span class="line">    transform: translate(-50%,-50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二种<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#container&#123;</span><br><span class="line">    position:relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#center&#123;</span><br><span class="line">    width:100px;</span><br><span class="line">    height:100px;</span><br><span class="line">    position:absolute;</span><br><span class="line">    top:50%;</span><br><span class="line">    left:50%;</span><br><span class="line">    margin:-50px 0 0 -50px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第三种<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#container&#123;</span><br><span class="line">    position:relative;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#center&#123;</span><br><span class="line">    position:absolute;</span><br><span class="line">    margin:auto;</span><br><span class="line">    top:0;</span><br><span class="line">    bottom:0;</span><br><span class="line">    left:0;</span><br><span class="line">    right:0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第四种 flex<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#container&#123;</span><br><span class="line">    display:flex;</span><br><span class="line">    justify-content:center;</span><br><span class="line">    align-items: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;水平垂直居中&quot;&gt;&lt;a href=&quot;#水平垂直居中&quot; class=&quot;headerlink&quot; title=&quot;水平垂直居中&quot;&gt;&lt;/a&gt;水平垂直居中&lt;/h3&gt;&lt;p&gt;html&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
    
      <category term="关于弹出层" scheme="http://LeilaBlog.site/tags/%E5%85%B3%E4%BA%8E%E5%BC%B9%E5%87%BA%E5%B1%82/"/>
    
  </entry>
  
  <entry>
    <title>CSRF攻击与防御</title>
    <link href="http://LeilaBlog.site/2018/03/15/CSRF%E6%94%BB%E5%87%BB%E4%B8%8E%E9%98%B2%E5%BE%A1/"/>
    <id>http://LeilaBlog.site/2018/03/15/CSRF攻击与防御/</id>
    <published>2018-03-15T03:54:17.000Z</published>
    <updated>2018-03-16T03:39:24.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>概念<br>CSRF概念：CSRF跨站点请求伪造(Cross—Site Request Forgery)，跟XSS攻击一样，存在巨大的危害性，你可以这样来理解：</li></ol><p>攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。 如下：其中Web A为存在CSRF漏洞的网站，Web B为攻击者构建的恶意网站，User C为Web A网站的合法用户。</p><ol start="2"><li>CSRF攻击介绍及防御</li></ol><p>CSRF攻击攻击原理及过程如下：</p><ol><li><p>用户C打开浏览器，访问受信任网站A，输入用户名和密码请求登录网站A；</p></li><li><p>在用户信息通过验证后，网站A产生Cookie信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；</p></li><li><p>用户未退出网站A之前，在同一浏览器中，打开一个TAB页访问网站B；</p></li><li><p>网站B接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点A；</p></li><li><p>浏览器在接收到这些攻击性代码后，根据网站B的请求，在用户不知情的情况下携带Cookie信息，向网站A发出请求。网站A并不知道该请求其实是由B发起的，所以会根据用户C的Cookie信息以C的权限处理该请求，导致来自网站B的恶意代码被执行。 </p></li></ol><p>CSRF攻击实例</p><p>受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求 <a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2" target="_blank" rel="noopener">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=bob2</a> 可以使 Bob 把 1000000 的存款转到 bob2 的账号下。通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。</p><p>黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。Mallory 可以自己发送一个请求给银行：<a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory。但是这个请求来自" target="_blank" rel="noopener">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory。但是这个请求来自</a> Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。</p><p>这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入如下代码： src=”<a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory" target="_blank" rel="noopener">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory</a> ”，并且通过广告等诱使 Bob 来访问他的网站。当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。但是，如果 Bob 当时恰巧刚访问他的银行后不久，他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。而 Mallory 则可以拿到钱后逍遥法外。</p><p>CSRF漏洞检测：</p><p>检测CSRF漏洞是一项比较繁琐的工作，最简单的方法就是抓取一个正常请求的数据包，去掉Referer字段后再重新提交，如果该提交还有效，那么基本上可以确定存在CSRF漏洞。</p><p>随着对CSRF漏洞研究的不断深入，不断涌现出一些专门针对CSRF漏洞进行检测的工具，如CSRFTester，CSRF Request Builder等。</p><p>以CSRFTester工具为例，CSRF漏洞检测工具的测试原理如下：使用CSRFTester进行测试时，首先需要抓取我们在浏览器中访问过的所有链接以及所有的表单等信息，然后通过在CSRFTester中修改相应的表单等信息，重新提交，这相当于一次伪造客户端请求。如果修改后的测试请求成功被网站服务器接受，则说明存在CSRF漏洞，当然此款工具也可以被用来进行CSRF攻击。</p><p>防御CSRF攻击：<br>目前防御 CSRF 攻击主要有三种策略：验证 HTTP Referer 字段；在请求地址中添加 token 并验证；在 HTTP 头中自定义属性并验证。</p><p>（1）验证 HTTP Referer 字段</p><p>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。在通常情况下，访问一个安全受限页面的请求来自于同一个网站，比如需要访问 <a href="http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory，用户必须先登陆" target="_blank" rel="noopener">http://bank.example/withdraw?account=bob&amp;amount=1000000&amp;for=Mallory，用户必须先登陆</a> bank.example，然后通过点击页面上的按钮来触发转账事件。这时，该转帐请求的 Referer 值就会是转账按钮所在的页面的 URL，通常是以 bank.example 域名开头的地址。而如果黑客要对银行网站实施 CSRF 攻击，他只能在他自己的网站构造请求，当用户通过黑客的网站发送请求到银行时，该请求的 Referer 是指向黑客自己的网站。因此，要防御 CSRF 攻击，银行网站只需要对于每一个转账请求验证其 Referer 值，如果是以 bank.example 开头的域名，则说明该请求是来自银行网站自己的请求，是合法的。如果 Referer 是其他网站的话，则有可能是黑客的 CSRF 攻击，拒绝该请求。</p><p>这种方法的显而易见的好处就是简单易行，网站的普通开发人员不需要操心 CSRF 的漏洞，只需要在最后给所有安全敏感的请求统一增加一个拦截器来检查 Referer 的值就可以。特别是对于当前现有的系统，不需要改变当前系统的任何已有代码和逻辑，没有风险，非常便捷。</p><p>然而，这种方法并非万无一失。Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。如果 bank.example 网站支持 IE6 浏览器，黑客完全可以把用户浏览器的 Referer 值设为以 bank.example 域名开头的地址，这样就可以通过验证，从而进行 CSRF 攻击。</p><p>即便是使用最新的浏览器，黑客无法篡改 Referer 值，这种方法仍然有问题。因为 Referer 值会记录下用户的访问来源，有些用户认为这样会侵犯到他们自己的隐私权，特别是有些组织担心 Referer 值会把组织内网中的某些信息泄露到外网中。因此，用户自己可以设置浏览器使其在发送请求时不再提供 Referer。当他们正常访问银行网站时，网站会因为请求没有 Referer 值而认为是 CSRF 攻击，拒绝合法用户的访问。</p><p>（2）在请求地址中添加 token 并验证</p><p>CSRF 攻击之所以能够成功，是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于 cookie 中，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的 cookie 来通过安全验证。要抵御 CSRF，关键在于在请求中放入黑客所不能伪造的信息，并且该信息不存在于 cookie 之中。可以在 HTTP 请求中以参数的形式加入一个随机产生的 token，并在服务器端建立一个拦截器来验证这个 token，如果请求中没有 token 或者 token 内容不正确，则认为可能是 CSRF 攻击而拒绝该请求。</p><p>这种方法要比检查 Referer 要安全一些，token 可以在用户登陆后产生并放于 session 之中，然后在每次请求时把 token 从 session 中拿出，与请求中的 token 进行比对，但这种方法的难点在于如何把 token 以参数的形式加入请求。对于 GET 请求，token 将附在请求地址之后，这样 URL 就变成 <a href="http://url?csrftoken=tokenvalue。" target="_blank" rel="noopener">http://url?csrftoken=tokenvalue。</a> 而对于 POST 请求来说，要在 form 的最后加上 <code>&lt;input type=”hidden” name=”csrftoken” value=”tokenvalue”/&gt;</code>，这样就把 token 以参数的形式加入请求了。但是，在一个网站中，可以接受请求的地方非常多，要对于每一个请求都加上 token 是很麻烦的，并且很容易漏掉，通常使用的方法就是在每次页面加载时，使用 javascript 遍历整个 dom 树，对于 dom 中所有的 a 和 form 标签后加入 token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 html 代码，这种方法就没有作用，还需要程序员在编码时手动添加 token。</p><p>该方法还有一个缺点是难以保证 token 本身的安全。特别是在一些论坛之类支持用户自己发表内容的网站，黑客可以在上面发布自己个人网站的地址。由于系统也会在这个地址后面加上 token，黑客可以在自己的网站上得到这个 token，并马上就可以发动 CSRF 攻击。为了避免这一点，系统可以在添加 token 的时候增加一个判断，如果这个链接是链到自己本站的，就在后面添加 token，如果是通向外网则不加。不过，即使这个 csrftoken 不以参数的形式附加在请求之中，黑客的网站也同样可以通过 Referer 来得到这个 token 值以发动 CSRF 攻击。这也是一些用户喜欢手动关闭浏览器 Referer 功能的原因。</p><p> （3）在 HTTP 头中自定义属性并验证</p><p>这种方法也是使用 token 并进行验证，和上一种方法不同的是，这里并不是把 token 以参数的形式置于 HTTP 请求之中，而是把它放到 HTTP 头中自定义的属性里。通过 XMLHttpRequest 这个类，可以一次性给所有该类请求加上 csrftoken 这个 HTTP 头属性，并把 token 值放入其中。这样解决了上种方法在请求中加入 token 的不便，同时，通过 XMLHttpRequest 请求的地址不会被记录到浏览器的地址栏，也不用担心 token 会透过 Referer 泄露到其他网站中去。</p><p>然而这种方法的局限性非常大。XMLHttpRequest 请求通常用于 Ajax 方法中对于页面局部的异步刷新，并非所有的请求都适合用这个类来发起，而且通过该类请求得到的页面不能被浏览器所记录下，从而进行前进，后退，刷新，收藏等操作，给用户带来不便。另外，对于没有进行 CSRF 防护的遗留系统来说，要采用这种方法来进行防护，要把所有请求都改为 XMLHttpRequest 请求，这样几乎是要重写整个网站，这代价无疑是不能接受的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;概念&lt;br&gt;CSRF概念：CSRF跨站点请求伪造(Cross—Site Request Forgery)，跟XSS攻击一样，存在巨大的危害性，你可以这样来理解：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全
      
    
    </summary>
    
    
      <category term="网络安全 信息安全 密码学" scheme="http://LeilaBlog.site/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8-%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>跨域资源共享CORS</title>
    <link href="http://LeilaBlog.site/2018/03/14/%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%ABCORS/"/>
    <id>http://LeilaBlog.site/2018/03/14/跨域资源共享CORS/</id>
    <published>2018-03-14T02:21:59.000Z</published>
    <updated>2018-03-15T03:50:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p><p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p><p>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p><h3 id="二、两种请求"><a href="#二、两种请求" class="headerlink" title="二、两种请求"></a>二、两种请求</h3><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p><p>只要同时满足以下两大条件，就属于简单请求。</p><p>（1) 请求方法是以下三种方法之一：</p><ul><li>HEAD</li><li>GET</li><li>POST</li></ul><p>（2）HTTP的头信息不超出以下几种字段：</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain</li></ul><p><strong>凡是不同时满足上面两个条件，就属于非简单请求。</strong></p><p>凡是不同时满足上面两个条件，就属于非简单请求。</p><p>浏览器对于这两种请求的处理是不一样的</p><h3 id="三、简单请求"><a href="#三、简单请求" class="headerlink" title="三、简单请求"></a>三、简单请求</h3><p>3.1 基本流程<br>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。</p><p>下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个Origin字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure><p>上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p><p>如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</p><p>如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure><p>上面的头信息之中，有三个与CORS请求相关的字段，都以Access-Control-开头。</p><p>（1）Access-Control-Allow-Origin</p><p>该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。</p><p>（2）Access-Control-Allow-Credentials</p><p>该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</p><p>（3）Access-Control-Expose-Headers</p><p>该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。</p><p>3.2 withCredentials 属性</p><p>上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure></p><p>另一方面，开发者必须在AJAX请求中打开withCredentials属性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = true;</span><br></pre></td></tr></table></figure><p>否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。</p><p>但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.withCredentials = false;</span><br></pre></td></tr></table></figure><p>需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。</p><h3 id="四、非简单请求"><a href="#四、非简单请求" class="headerlink" title="四、非简单请求"></a>四、非简单请求</h3><p>4.1 预检请求<br>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。</p><p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p><p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p><p>下面是一段浏览器的JavaScript脚本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var url = &apos;http://api.alice.com/cors&apos;;</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&apos;PUT&apos;, url, true);</span><br><span class="line">xhr.setRequestHeader(&apos;X-Custom-Header&apos;, &apos;value&apos;);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure></p><p>上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。</p><p>浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure><p>“预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。</p><p>除了Origin字段，”预检”请求的头信息包括两个特殊字段。</p><p>（1）Access-Control-Request-Method</p><p>该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。</p><p>（2）Access-Control-Request-Headers</p><p>该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。</p><p>4.2 预检请求的回应<br>服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line">Server: Apache/2.0.61 (Unix)</span><br><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 0</span><br><span class="line">Keep-Alive: timeout=2, max=100</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/plain</span><br></pre></td></tr></table></figure><p>上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示<a href="http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。" target="_blank" rel="noopener">http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</a></p><p>Access-Control-Allow-Origin: *</p><p>如果浏览器否定了”预检”请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XMLHttpRequest cannot load http://api.alice.com.</span><br><span class="line">Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.</span><br></pre></td></tr></table></figure><p>服务器回应的其他CORS相关字段如下。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Max-Age: 1728000</span><br></pre></td></tr></table></figure></p><p>（1）Access-Control-Allow-Methods</p><p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。</p><p>（2）Access-Control-Allow-Headers</p><p>如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。</p><p>（3）Access-Control-Allow-Credentials</p><p>该字段与简单请求时的含义相同。</p><p>（4）Access-Control-Max-Age</p><p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p><p>4.3 浏览器的正常请求和回应<br>一旦服务器通过了”预检”请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。</p><p>下面是”预检”请求之后，浏览器的正常CORS请求。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">X-Custom-Header: value</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure></p><p>上面头信息的Origin字段是浏览器自动添加的。</p><p>下面是服务器正常的回应。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure></p><p>上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。</p><h3 id="五、与JSONP的比较"><a href="#五、与JSONP的比较" class="headerlink" title="五、与JSONP的比较"></a>五、与JSONP的比较</h3><p>CORS与JSONP的使用目的相同，但是比JSONP更强大。</p><p>JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、简介&quot;&gt;&lt;a href=&quot;#一、简介&quot; class=&quot;headerlink&quot; title=&quot;一、简介&quot;&gt;&lt;/a&gt;一、简介&lt;/h3&gt;&lt;p&gt;CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。&lt;/p&gt;
&lt;p&gt;整个CORS通
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CCTalk工程</title>
    <link href="http://LeilaBlog.site/2018/03/13/CCTalk%E5%B7%A5%E7%A8%8B/"/>
    <id>http://LeilaBlog.site/2018/03/13/CCTalk工程/</id>
    <published>2018-03-13T09:51:30.000Z</published>
    <updated>2018-03-16T09:12:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>前后端分离的开发方式</p><p>前端有独立的代码仓库，独立的构建和发布流程<br>和后端异步请求数据，约定接口规范(数据返回格式和结构，规范和状态码)<br>前后端需要统一的API管理平台<br>先写文档，再开发</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前后端分离的开发方式&lt;/p&gt;
&lt;p&gt;前端有独立的代码仓库，独立的构建和发布流程&lt;br&gt;和后端异步请求数据，约定接口规范(数据返回格式和结构，规范和状态码)&lt;br&gt;前后端需要统一的API管理平台&lt;br&gt;先写文档，再开发&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="前端工程化 react工程化 前后端分离" scheme="http://LeilaBlog.site/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96-react%E5%B7%A5%E7%A8%8B%E5%8C%96-%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB/"/>
    
  </entry>
  
  <entry>
    <title>面试经</title>
    <link href="http://LeilaBlog.site/2018/03/13/%E9%9D%A2%E8%AF%95%E7%BB%8F/"/>
    <id>http://LeilaBlog.site/2018/03/13/面试经/</id>
    <published>2018-03-13T02:33:26.000Z</published>
    <updated>2018-04-23T10:04:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何学习前端的"><a href="#如何学习前端的" class="headerlink" title="如何学习前端的"></a>如何学习前端的</h3><ol><li>js高级教程第三版，接下来就是做项目，接触一些框架，然后，就开始学习框架，以及个人对于框架的一些看法。</li></ol><p>学习js基础的话，不单单要看红宝石（js高级教程第三版），也要看看js的犀牛书（js权威指南）比较好一点。</p><ol start="2"><li>有了解js的数据类型吗？</li></ol><p>ES5的基本数据类型，Undefined，Null，Number，String，Boolean，引用类型，Object。ES6新增了数据类型Symbol，表示独一无二的值。</p><ol start="3"><li>有了解js的事件吗？</li></ol><p><img src="http://oqt3f60vc.bkt.clouddn.com/js%E6%B5%81.jpg" alt="js的事件流"></p><p>一个完整的JS事件流是从window开始，最后回到window的一个过程。</p><p>事件流被分为三个阶段(1~ 5)捕获过程、(5~ 6)事件触发过程、(6~ 10)冒泡过程。</p><ol start="4"><li>移动端的触摸事件</li></ol><p>触摸事件指的是指的是用户将手指放在屏幕上，在屏幕上滑动到将手指从屏幕移开触发的事件，具体来说，有以下触摸事件的产生：</p><ul><li>touchstart: 当手指触摸屏幕时候触发；</li><li>touchmove: 当手指在屏幕上滑动的时候连续触发；可以调用阻止默认事件preventDefault()阻止屏幕滚动；</li><li>touchend: 手指离开屏幕时触发；</li><li>touchcancel: 系统停止跟踪触摸时触发；</li></ul><p>以上的这些事件都会冒泡，而且都可以取消冒泡，而且，对于以上事件也提供了和鼠标事件中常用的属性：bubble,cancelable,view,clientX,clientY,screenX,screenY,detail,altKey,shiftKey,ctrKey和metaKey。</p><p>除了上面这些属性外，触摸事件还提供了下面这些属性：</p><ul><li>touches: 跟踪返回Touch对象的数组；</li><li>targetTouchs: 特定事件目标的Touch对象的数组；</li><li>changeTouchs: 上次触摸以来改变了的Touch对象的数组；</li></ul><p>每个Touch对象包含一下的属性：</p><ul><li>clientX: 触摸目标在浏览器中的x坐标</li><li>clientY: 触摸目标在浏览器中的y坐标</li><li>identifier: 标识触摸的唯一ID。</li><li>pageX: 触摸目标在当前DOM中的x坐标</li><li>pageY: 触摸目标在当前DOM中的y坐标</li><li>screenX: 触摸目标在屏幕中的x坐标</li><li>screenY: 触摸目标在屏幕中的y坐标</li><li>target: 触摸的DOM节点目标。</li></ul><ol start="4"><li>页面加载过程，就是输入url到加载出页面</li></ol><p>这里发生了：</p><ul><li>输入地址</li><li>浏览器查找域名的 IP 地址</li><li>这一步包括 DNS 具体的查找过程，包括：浏览器缓存-&gt;系统缓存-&gt;路由器缓存…</li><li>浏览器向 web 服务器发送一个 HTTP 请求</li><li>服务器的永久重定向响应（从 <a href="http://example.com" target="_blank" rel="noopener">http://example.com</a> 到 <a href="http://www.example.com）" target="_blank" rel="noopener">http://www.example.com）</a></li><li>浏览器跟踪重定向地址</li><li>服务器处理请求</li><li>服务器返回一个 HTTP 响应</li><li>浏览器显示 HTML</li><li>浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）</li><li>浏览器发送异步请求</li></ul><ol start="5"><li>状态码的了解:<br>……</li></ol><ul><li>200 成功</li><li>304状态码 —— 客户端发送了一个带条件的GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个304状态码。简单的表达就是：客户端已经执行了GET，但文件未变化。</li></ul><ol start="6"><li>路由器的缓存</li></ol><p>每个路由器根据所在网络的不同，都有自己的路由表，在工作时会选择相应的路径。为什么要有路由器缓存呢，这个也是为了发送数据，因为路由器最高层一般都是网络层，网络层一般都是传送数据包，数据包又是经过应用层向下传送之后送来的一部分文件数据，如果我们没有缓存的话，那么，每次都会查找传送到达方的ip地址就会很费力。</p><ol start="7"><li><p>项目中有遇到跨域吗？跨域的原理是什么？<br>有呢<br>一般用vue做项目，然后解决跨域又是用webpack里面配置的poxyTable进行解决跨域，相当于用代理工具，</p></li><li><p>代理是怎么样有了解原理吗，以及跨域的原理，以及浏览器跨域的原因。</p></li></ol><p>跨域的原理:<br>什么是跨域？跨域就是它是由浏览器的同源策略造成的，是浏览器施加的安全限制。</p><p>所谓同源是指，域名，协议，端口均相同，不明白可以看看下面的例子：</p><ul><li><p><a href="http://www.123.com/index.html" target="_blank" rel="noopener">http://www.123.com/index.html</a> 调用 <a href="http://www.123.com/server.php" target="_blank" rel="noopener">http://www.123.com/server.php</a> （非跨域）</p></li><li><p><a href="http://www.123.com/index.html" target="_blank" rel="noopener">http://www.123.com/index.html</a> 调用 <a href="http://www.456.com/server.php" target="_blank" rel="noopener">http://www.456.com/server.php</a> （主域名不同:123/456，跨域）</p></li><li><p><a href="http://abc.123.com/index.html" target="_blank" rel="noopener">http://abc.123.com/index.html</a> 调用 <a href="http://def.123.com/server.php" target="_blank" rel="noopener">http://def.123.com/server.php</a> （子域名不同:abc/def，跨域）</p></li><li><p><a href="http://www.123.com:8080/index.html" target="_blank" rel="noopener">http://www.123.com:8080/index.html</a> 调用 <a href="http://www.123.com:8081/server.php" target="_blank" rel="noopener">http://www.123.com:8081/server.php</a> （端口不同:8080/8081，跨域）</p></li><li><p><a href="http://www.123.com/index.html" target="_blank" rel="noopener">http://www.123.com/index.html</a> 调用 <a href="https://www.123.com/server.php" target="_blank" rel="noopener">https://www.123.com/server.php</a> （协议不同:http/https，跨域）</p></li></ul><p>为什么要实现跨域？防止CSRF攻击<br>关于CSRF <a href="http://blog.csdn.net/stpeace/article/details/53512283" target="_blank" rel="noopener">介绍CSRF</a></p><ol start="9"><li>你是怎么解决跨域的？说说Cors解决的方法，和你用的jsonp的解决的原理</li></ol><p>用jsonp解决跨域的，然后面试官叫我说明一下jsonp跨域的原理</p><p>其实Cors方法更好<br>阮一峰的跨域资源共享CORS详解 <a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">共享CORS详解</a></p><p>对于jsonp跨域的工作原理 github上面看看<a href="https://github.com/webmodules/jsonp" target="_blank" rel="noopener">源代码</a>就可以理解。</p><ol start="10"><li>有了解作用域吗？怎么预防作用域污染</li></ol><p>作用域无非就是js当做对于function函数声明会提升到其他声明语句前执行，以及对于某个 {}里面的作用域如果找不到某个属性，就会在该 {}上下文当中查找属性，如果还找不到的话，进而类似。</p><p>作用域污染，无非就是闭包了吧，个人理解。</p><ol start="11"><li>说说闭包</li></ol><p>建议还是直接看看js高级教程第三版里面的书本吧。<br>其实闭包也就是指有权访问另一个函数作用域的函数而已。常用的创建闭包的方法就是在函数内部创建另一个函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function a()&#123;</span><br><span class="line">    var a;</span><br><span class="line">    // ...</span><br><span class="line">    return</span><br><span class="line">    function()&#123;</span><br><span class="line">        // 这里可以引用a函数里面的作用域，也就是可以使用a</span><br><span class="line">        // 而且a函数作用域无法使用这里的值。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="12"><li>了解前端的缓存吗？缓存分为几类？</li></ol><p>前端的缓存无非就Cookie,LocalStorge,SessionStorge这三个吧。</p><p>Cookie，存储容量小，仅仅4kb左右，在网络请求的时候可以发送，不建议存储重要数据，因为会被网络诈骗就是把本地的cookie发到别人的服务器上，进而获取你的账户密码。</p><p>LocalStorge,SessionStorge都是本地缓存的主要用的，两者的用法都很简单，都有各自的Set和get方法。主要的区别就是LocalStorge是一种持久化的存储方式，也就是说如果不手动清除，数据就永远不会过期。而SessionStorge关闭浏览器就清空数据。</p><ol start="11"><li>怎么才算一个好的前端开发者</li></ol><p>······<br>······</p><ol start="12"><li>你还有什么问题想问吗<br>问面试官的的评价：<br>基础知识可以再多去学习，不用太着急学习框架，市面上的框架千变万化，只有基础知识比较好才能够学习的更好，而且需要多学习一下性能优化，网络，安全这方面，因为在大公司里面，其实重要的东西并不是你能够做的多好看，而是你的安全性那些做的好不好，一不小心信息泄露了，那就会导致很多无法想象的事情，<br><a href="https://pan.baidu.com/s/1CvttJuNetZvgVjrXG1ZFSA" target="_blank" rel="noopener">图解http协议</a>密码：u35q</li></ol><p>建议我就是基础知识学更多一些，把知识都规范体系化，这样以后碰到问题了就会一下子就知道是哪方面的问题，直接去解决</p><p>面试官给我从以下几个方面进行说明，我也真的是收获颇多。</p><ul><li>js基础</li><li>计算机网络</li><li>性能优化</li><li>开发技巧</li><li>移动端知识</li><li>安全性问题<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3>不管怎么说，不管结果好坏，跟腾讯大牛的聊天都是值得积累的过程，不要想象的很紧张吧，这也是自己能够收获知识的时候，我是这样觉得的，哈哈</li></ul><p><strong>2018.4.10日</strong></p><h4 id="js中Ajax发送请求的步骤："><a href="#js中Ajax发送请求的步骤：" class="headerlink" title="js中Ajax发送请求的步骤："></a>js中Ajax发送请求的步骤：</h4><p>在js中，有一个用于异步请求的对象，XMLHttpRquest对象，使用该对象可以向服务端发送请求(post,get,put…)。原生的方法步骤如下:</p><p>① 创建XMLHttpRequest对象（标准浏览器）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(window.xhrHttpRequest)&#123;</span><br><span class="line">    var xhr = new xhrHttpRequest();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IE7及其以下，这个对象为：ActiveXObject;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if(window.xhrHttpRequest)&#123;</span><br><span class="line">    var xhr = new ActiveXObject(&quot;Microsoft.XMLHTTp&quot;);  </span><br><span class="line">&#125;</span><br><span class="line">```  </span><br><span class="line">② 初始化请求</span><br></pre></td></tr></table></figure></p><p>xhr.open(‘get’,’http:www.请求网址.com’,是否异步？true:false);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">③发送请求/传递数据</span><br></pre></td></tr></table></figure></p><p>xhr.send();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请求的文件路径，如果是GET方式，直接缀在请求地址的后面，以如下的形式：</span><br></pre></td></tr></table></figure></p><p>//数据<br>xhr.open(‘GET’,’<a href="http://www.请求地址.com/index.html&#39;,true[异步请求])" target="_blank" rel="noopener">http://www.请求地址.com/index.html&#39;,true[异步请求])</a>;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果是post方法则请求路径直接写到xhr.send(&apos;数据&apos;)中</span><br><span class="line"></span><br><span class="line">④设置异步回调callback()</span><br><span class="line"></span><br><span class="line">错误示范</span><br></pre></td></tr></table></figure></p><p>xhr.readyState 本地的请求状态<br>xhr.status    服务器返回请求的状态码<br>if(xhr.readySate == 4 &amp;&amp; xhr.status == 200){<br>    doSometing<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这里的本质原因是没有本地xhr对象改变的事件，因此这里的readystate会一直等于 1</span><br><span class="line"></span><br><span class="line">这里的异步方式主要通过一个事件来完成</span><br></pre></td></tr></table></figure></p><p>xhr.onreadystatechange() = function(){<br>    if(xhr.readyState == 4 &amp;&amp; xhr.status == 200){<br>        Todo<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">如果在步骤②中请求的方式是同步的，一旦服务器压力过大，没有及时响应，那么代码会一直卡在这里，一直傻傻的等到服务器响应200，才会do something。</span><br><span class="line"></span><br><span class="line">反之，如果请求方式是异步的，那么这里的响应无论是否及时，都不会阻塞后面的代码。</span><br><span class="line"></span><br><span class="line">扩展：既然 readyState==4 &amp;&amp; status ==200 是一个回调，那么我们也可以使用其他的http状态码来设置不同的回调~ </span><br><span class="line"></span><br><span class="line">xhr.open()初始化 xhr.send()发送请求 xhr.onreadystatechange=function()&#123;&#125;回调函数 这三点都忘记答了，一定要注意。</span><br><span class="line"></span><br><span class="line">#### 2. 浏览器里面的事件都会按照一定的规则去传递，这个规则是什么？</span><br><span class="line">事件捕获 事件响应 事件冒泡</span><br><span class="line">window =&gt; document =&gt; body =&gt; div =&gt; text</span><br><span class="line">事件捕获 从外向内 从大到小</span><br><span class="line">事件冒泡 从内向外 从小到大</span><br></pre></td></tr></table></figure></p><p>&lt;!DOCTYPE html&gt;</p><html lang="en"><head><br>    <meta charset="UTF-8"><br>    <meta name="viewport" content="width=device-width, initial-scale=1.0"><br>    <meta http-equiv="X-UA-Compatible" content="ie=edge"><br>    <title>Document</title><br></head><br><style><br>    #div1 {<br>        background: pink;<br>        width: 400px;<br>        height: 400px;<br>    }<br><br>    #div2 {<br>        background: rgb(14, 202, 139);<br>        width: 200px;<br>        height: 200px;<br>    }<br><br>    #btn {<br>        background: rgb(236, 5, 82);<br>        width: 100px;<br>        height: 100px;<br>    }<br></style><br><br><body><br>    <div id="div1"><br>        <div id="div2"><br>            <button id="btn"></button><br>        </div><br>    </div><br></body><br><script><br>    var div1 = document.getElementById(‘div1’);<br>    var div2 = document.getElementById(‘div2’);<br>    var btn = document.getElementById(‘btn’);<br>    div1.addEventListener(‘click’, function() {<br>        console.log(this.id)<br>    }, true);<br>    div2.addEventListener(‘click’, function() {<br>        console.log(this.id)<br>    }, true);<br>    btn.addEventListener(‘click’, function() {<br>        console.log(this.id)<br>    }, true);<br>    // Boolean?捕获:冒泡<br></script><br><br></html><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">// Boolean?捕获:冒泡 </span><br><span class="line">false == 冒泡</span><br><span class="line"></span><br><span class="line">console.log结果</span><br><span class="line"></span><br><span class="line">btn</span><br><span class="line"></span><br><span class="line">div2</span><br><span class="line"></span><br><span class="line">div1</span><br><span class="line"></span><br><span class="line">true == 捕获</span><br><span class="line"></span><br><span class="line">console.log结果</span><br><span class="line"></span><br><span class="line">div1</span><br><span class="line"></span><br><span class="line">div2</span><br><span class="line"></span><br><span class="line">btn</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">总结： </span><br><span class="line"></span><br><span class="line">1.addEventListener(事件，函数，boolean?捕获:冒泡)，这个API可以设置事件触发于捕获/冒泡阶段，而且这个事件可以复写。 </span><br><span class="line">2.普通的API,例如 onclick ,onmouse 默认只能在冒泡阶段触发，而且不能复写，复写事件会覆盖。</span><br><span class="line"></span><br><span class="line">#### 3.闭包是怎么回事？用在什么场景？</span><br><span class="line">简而言之：1、闭包就是可以访问局部作用域的变量。 </span><br><span class="line"></span><br><span class="line">并且： 2、 可以使局部变量常驻内存</span><br></pre></td></tr></table></figure><br><br>function a(){<br>    var a = 1;<br>    function b(){<br>        a+=1;<br>        return a;<br>    }<br>    return b();<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">因为此时的子函数b一直对于a函数的变量“a=1”有需求，因此这个变量会常驻内存，不会被销毁。</span><br><span class="line"></span><br><span class="line">##### Q3.1：什么时候才能够销毁这个内存呢？（销毁机制和人为销毁方法）</span><br><span class="line"></span><br><span class="line">A：浏览器中的js引擎有自己的垃圾回收机制，当一个变量或者对象引用为0的时候，会自动回收。 </span><br><span class="line">人为的销毁内存的办法：1.关闭网页，结束js运行环境。2.销毁变量，为变量赋值 null；</span><br><span class="line"></span><br><span class="line">##### Q3.2：如何避免内存泄漏的问题？ </span><br><span class="line">A：减少全局空间的污染，良好的变量定义习惯。减少变量的引用。</span><br><span class="line"></span><br><span class="line">4.CALL和Apply是干嘛的？</span><br><span class="line"></span><br><span class="line">两者都是为了改变函数中的this指向；</span><br><span class="line"></span><br><span class="line">call(新的this对象，原来参数1，原来参数2...);</span><br><span class="line"></span><br><span class="line">apply(新的this对象，[原来的参数1，原来的参数2...]);</span><br><span class="line"></span><br><span class="line">先传入新的this对象，再传入旧方法的传参</span><br><span class="line"></span><br><span class="line">#### 5.在平时开发中，遇到过跨域的问题吗？如何处理跨域呢？</span><br><span class="line"></span><br><span class="line">1.jsonp跨域 </span><br><span class="line">利用`&lt;script&gt;`标签的跨域特性，将请求的语句写在script标签的src属性上，然后定义一个方法，用于接受返回值responseText。代码如下：</span><br></pre></td></tr></table></figure><br><br>//在js预先定义好callback()函数<br><br>function fun(data){<br><br>    //use data to do somethings.<br><br>}<br><br><br>//动态创建script标签，并在url中说明请求地址<br>var body = document.getElementsByTagName(‘body’)[0];<br><br>var script = document.createElement(‘script’);<br><br>script.type = ‘text/javasctipt’;<br><br>script.src = ‘require.php?callback=fun’;<br><br>body.appendChild(script);<br><br>//Script插入完成，一旦服务端有响应，传递过来的响应文本会直接被当做js代码执行。<br>//假设传回的值是 fun({“name”:”xiaoming”})，那么小明这个对象会被当做参数传递给早就定义好的fun()函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">这样，通过script不受跨域访问的特性，实现了跨域访问。</span><br><span class="line"></span><br><span class="line">2. CORS跨域(主流浏览器及IE10以上)</span><br><span class="line"></span><br><span class="line">对于客户端，我们还是使用xhr对象发送Ajax请求</span><br><span class="line">唯一需要注意的事，我们需要设置我们的xhr属性withCredentials为true，不然cookie带不过去的，设置xhr.withCredentials = true;</span><br><span class="line"></span><br><span class="line">对于服务器，我们需要在response header中设置两个字段</span><br><span class="line"></span><br><span class="line">Access-Control-Allow-Origin: http://www.yourhost.com </span><br><span class="line"></span><br><span class="line">Access-Control-Allow-Credentials:true </span><br><span class="line"></span><br><span class="line">这样，我们就可以跨域请求接口了。</span><br><span class="line"></span><br><span class="line">3. 返回的json和jsonp有什么区别？ </span><br><span class="line"></span><br><span class="line">返回的json是json格式的文件，而返回的jsonp是字符串形式的文件，形如：</span><br></pre></td></tr></table></figure><br><br>callback({‘name’:’zxl’})<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 6. 简单说一说盒模型，W3C和IE怪异盒模型。</span><br><span class="line">W3C标准的盒模型：width = content_width(不包含border+padding+margin)</span><br><span class="line"></span><br><span class="line">IE怪异盒模型： width == content_width+padding+border</span><br><span class="line"></span><br><span class="line">#### 7.简要阐述XSS和CSRF攻击及防范</span><br><span class="line">7.1 XSS攻击与防范 </span><br><span class="line"></span><br><span class="line">注入攻击。 </span><br><span class="line"></span><br><span class="line">简而言之，XSS就是想方设法的在用户浏览的当前页面植入自己的script脚本，从而达到窃取用户信息，cookies等。</span><br><span class="line"></span><br><span class="line">防范的方法：对一些常用表单的输入字符前端要进行转义、过滤、判断，后端则需要对请求进行甄别，分辨是否为正常请求。</span><br><span class="line">ep:</span><br></pre></td></tr></table></figure><br><br><input type="text" value="<script>alert(123)</script>" name="input"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">正常的用户不会去输`&lt;script&gt;&lt;/script&gt;`之类的字符，所以前端要在js曾做一些表单的正则验证或者甄别来判断这个输入是否合法、正确</span><br><span class="line"></span><br><span class="line">7.2 CSRF的攻击与防范</span><br><span class="line"></span><br><span class="line">CSRF攻击就是在用户不知情的情况下借助用户信息向网站发起请求</span><br><span class="line">ep：用户访问A网站登陆以后没有关闭或者没有清除缓存，然后被诱导点击B网站，B网站发起恶意请求，此时A网站的服务端无法判断请求是否来自用户本意，因为用户已经登录了，有cookies，所以此时相当于是B网站借用户信息攻击A网站</span><br><span class="line"></span><br><span class="line">防范措施主要在后端，后端要严格的来甄别  请求是否有是用户的本意，常见的方法有验证请求头的Refer字段，加token验证等</span><br><span class="line"></span><br><span class="line">#### 8.强类型语言有继承，在JS里面如何做到继承呢？(proto和prototype)</span><br><span class="line"></span><br><span class="line">在JS中，继承主要是通过函数原型链来完成的。每个函数创建的时候都有一个_proto_对象，构造函数则有一个prototype对象，该对象上挂载的是可以继承的方法、属性等等。</span><br><span class="line"></span><br><span class="line">8.1 构造函数内部有一个test()方法，prototype上也挂着一个test()方法，二者有何不同？</span><br><span class="line"></span><br><span class="line">通过实例化对象来继承，只能继承prototype的方法，而内部的test()无权访问</span><br><span class="line"></span><br><span class="line">#### 9.页面性能优化有哪些方式？</span><br><span class="line"></span><br><span class="line">1. 压缩css、js、img等使用spirit等</span><br><span class="line">2. 减少请求次数</span><br><span class="line">3. 减少页面的重排、重灰</span><br><span class="line">4. 使用懒加载，按需加载</span><br><span class="line">5. c3的动画保持有限的帧率</span><br><span class="line">6. 减少DOM的访问次数，对经常访问的节点/属性，进行定义并赋值</span><br><span class="line">7. 减少代码的冗余量，精简代码</span><br><span class="line">8. 静态资源部署到CDN节点</span><br><span class="line"></span><br><span class="line">9.1 重绘/重排是怎么回事？有什么区别？</span><br><span class="line"></span><br><span class="line">网页加载时会根据DOM节点构造出一个DOM树，同时根据css来构造出css树,最后合并DOM树和css树形成render树，render树会将所有元素进行渲染排布，</span><br><span class="line"></span><br><span class="line">例如当使用js动态添加元素的时候，Dom树的构造就会发生变化，浏览器就会发生dom树就会发生重排</span><br><span class="line"></span><br><span class="line">当dom节点的几个，十几个，几十个Dom节点的样式发生变化，浏览器不得不把这些变化的属相重新进项渲染，在用户的浏览器的view层得到体现，这样就发生重绘</span><br><span class="line"></span><br><span class="line">重排是发生再Dom节点，预先为Dom节点留好坑，一点有Dom节点增删，位置变动，宽高变化就会要对其进行重新排布，排布是发生在Dom树的。</span><br><span class="line">一旦dom树改变，css渲染数的子节点，孙节点都发生变化，此时就要进行重绘</span><br><span class="line"></span><br><span class="line">**重排一定会发生重绘**</span><br><span class="line"></span><br><span class="line">重绘的过程中实际上先有确定的Dom树，根据Dom树构造出一个结构节点相同的css树，来对前者进行绘制，一旦Dom树发生变化，css树也会发生变化，此时就会造成浏览器的重绘</span><br><span class="line"></span><br><span class="line">如果Dom树没有发生变化，仅仅是css发生变化，此过程没有重排但有进行重绘</span><br><span class="line"></span><br><span class="line">**重绘现象的发生有可能以重排为前提**</span><br><span class="line"></span><br><span class="line">9.2 请举例说明重绘，什么情况下会重绘？</span><br><span class="line"></span><br><span class="line">重排会引发重绘，样式属性（例如字体，颜色，背景色）等改变会引起重绘</span><br><span class="line"></span><br><span class="line">9.3 你认为样式是会引起重绘的吗？什么样式会引起重绘/重排？什么属性会引起重绘/重排？ </span><br><span class="line"></span><br><span class="line">样式会引起重绘</span><br><span class="line"></span><br><span class="line">color，background等改变会引起重绘</span><br><span class="line"></span><br><span class="line">浏览器窗口变化，DOM结构树（包括文本节点比变化会引起重排）</span><br><span class="line"></span><br><span class="line">#### 10. 浏览器如何知道一个css文件,js文件需要缓存？</span><br><span class="line">首先浏览器访问某个站点的时候会检查本地是否会有缓存，如果没有会访问服务器去请求，如果有的话，查看缓存是不是新鲜，如果不新鲜，，就去询问服务器我的缓存到到期了，你那边更新了么？如果没有更新，仍然使用本地的缓存，这是服务器会返回304，意思我这边没有更新，你就是用以前的吧。</span><br><span class="line"></span><br><span class="line">![](http://oqt3f60vc.bkt.clouddn.com/request.png)</span><br><span class="line"></span><br><span class="line">#### 11.HTTP状态码304,502,503</span><br><span class="line">304缓存未更新继续使用之前的缓存，无需向服务器请求此文件的静态资源</span><br><span class="line"></span><br><span class="line">502服务器作为网管或代理，从上游服务器收到无效响应</span><br><span class="line"></span><br><span class="line">503服务器停机维护</span><br><span class="line"></span><br><span class="line">http状态码</span><br><span class="line"></span><br><span class="line">1XX:临时响应并继续等待客户端的请求</span><br><span class="line"></span><br><span class="line">2xx：成功 201已创建 202已接受 203未授权信息 204无返回内容 205重置内容</span><br><span class="line"></span><br><span class="line">3xx：重定向 300多种选择 301资源永久移动 302 资源临时移动    303自动转到其他位置 304 未修改  </span><br><span class="line"></span><br><span class="line">4xx：请求错误 401未授权  403禁止请求   404未找到    406不接受 408超时</span><br><span class="line"></span><br><span class="line">5xx：服务器错误 500内部错误，501 尚未实施，502 错误网关，503 请求不可用。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 12.Nodejs出现问题，怎么处理异常？已经上线的项目，如何处理异常？</span><br><span class="line">首先就是灰度发布，单位里有test服务器，可以直接部署到test上面，模拟上线环境，通过多个使用场景来监测应用是否健壮，例如:超大UV,高并发，加载时间等等，还要看页面中是否有静态资源出现路径错误，以及代码中写错/疏忽/遗漏的地方。</span><br><span class="line"></span><br><span class="line">如果没有这个灰度发布的条件，项目上线出了问题，应该第一时间向leader反映，并寻求BUG处理的流程，如果项目访问量不大，可以在夜间偷偷填坑，如果访问量大，那么可以紧急追溯错误来源，并赶紧发布补丁/覆盖原有资源，避免造成不良影响的进一步扩大。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 编程大题</span><br><span class="line"></span><br><span class="line">##### 1. 页面内有一个正方形元素A以及一个待放置区域B，实现对其拖拽和放下到B区域内，并且改变B区域背景颜色(不可用html5原生事件)。【考基本功，DOM、事件、定位、jsAPI】</span><br></pre></td></tr></table></figure><br><br>&lt;!DOCTYPE html&gt;<br><html lang="en"><br><br><head><br>    <meta charset="UTF-8"><br>    <title>Document</title><br>    <style><br>        #dog {<br>            width: 150px;<br>            height: 150px;<br>            background: red;<br>            position: absolute;<br>        }<br><br>        #areaB {<br>            width: 300px;<br>            height: 100%;<br>            background: rgb(3, 240, 208);<br>            position: absolute;<br>            right: 0px;<br>        }<br>    </style><br>    <script><br>        window.onload = function() {<br>            var odiv = document.getElementById(“dog”);<br>            var areaB = document.getElementById(‘areaB’);<br>            odiv.onmousedown = function(ev) {<br>                    var oEvent = ev || event;<br><br>                    var gapX = oEvent.clientX - odiv.offsetLeft;<br>                    var gapY = oEvent.clientY - odiv.offsetTop;<br><br>                    document.onmousemove = function(ev) {<br>                        var oEvent = ev || event;<br>                        if (oEvent.clientX &lt; 0) {<br>                            document.onmousemove = null;<br>                            document.onmouseup = null;<br>                        } else {<br>                            //限制在可视区域内运动<br>                            var l = oEvent.clientX - gapX;<br>                            var t = oEvent.clientY - gapY;<br>                            var r = document.documentElement.clientWidth - odiv.offsetWidth;<br>                            var b = document.documentElement.clientHeight - odiv.offsetHeight;<br>                            if (l &lt; 0) {<br>                                odiv.style.left = 0 + “px”;<br>                            } else if (l &gt; r) {<br>                                odiv.style.left = r + “px”;<br>                            } else {<br>                                odiv.style.left = l + “px”;<br>                            }<br>                            if (t &lt; 0) {<br>                                odiv.style.top = 0 + “px”;<br>                            } else if (t &gt; b) {<br>                                odiv.style.top = b + “px”;<br>                            } else {<br>                                odiv.style.top = t + “px”;<br>                            }<br>                        }<br><br>                        var into = document.documentElement.clientWidth - odiv.offsetWidth - areaB.offsetWidth;<br>                        if (l &gt; into) {<br>                            areaB.style.background = ‘orange’;<br>                            odiv.style.zIndex = 1;<br>                        } else {<br>                            areaB.style.background = ‘rgb(3, 240, 208)’;<br>                        }<br>                    }<br>                }<br>                //松开鼠标，停止拖拽<br>            odiv.onmouseup = function() {<br>                document.onmousemove = null;<br>                document.onmouseup = null;<br>            }<br>        }<br>    </script><br></head><body><br>    <div id="dog"></div><br>    <div id="areaB"></div><br></body><p></p></html><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 2.实现超出整数存储范围的两个大正整数相加 function add(a, b) 。 </span><br><span class="line">注意：参数 a 和 b 以及函数的返回值都是字符串。【考算法，基本逻辑】</span><br><span class="line"></span><br><span class="line">&quot;hello&quot;.split(&quot;&quot;)    //可返回 [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;,&quot;l&quot;,&quot;o&quot;]</span><br><span class="line">&quot;hello&quot;.split(&quot;&quot;,3)  //可返回 [&quot;h&quot;, &quot;e&quot;, &quot;l&quot;]</span><br><span class="line"></span><br><span class="line">myGod 不会</span><br><span class="line"></span><br><span class="line">##### 3、页面内有一个input输入框，实现在数组arr查询命中词并和autocomplete效果。 【考原理，基础】</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### 0.怪异盒模型</span><br><span class="line">IE9以上及其他浏览器我们的盒子模型 content</span><br><span class="line">IE及IE8以下浏览器的盒子模型      content + padding + border</span><br><span class="line"></span><br><span class="line">#### background-orgin:   </span><br><span class="line"></span><br><span class="line">可选择的值为：content-box margin-box padding-box</span><br><span class="line"></span><br><span class="line">(1) content-box 即采用W3C标准，不急border padding margin 得出盒子   </span><br><span class="line">(2) padding-box 渲染盒子的时候，把padding当做盒子宽高的组成部分 即在标准的盒子模型的基础上，宽高都加上padding px</span><br><span class="line">(3) margin-box 同理 宽高都增加margin px</span><br><span class="line"></span><br><span class="line">border-radius：圆角边框 假如div的宽 = 高 即为正方形 若此时border-radius = div的宽/高，那么此时div是一个圆形; 若border-radius远远大于div的宽/高，那么还是一个圆形，不会变化</span><br><span class="line"></span><br><span class="line">因此 background-origin的值 就取决于背景图从那个盒子模型开始渲染</span><br><span class="line"></span><br><span class="line">#### box-shadow  box-shadow: h-shadow v-shadow blur spread color inset;</span><br><span class="line"></span><br><span class="line">#### text-shadow :水平偏移 垂直偏移 阴影距离文字的index距离 颜色</span><br><span class="line"></span><br><span class="line">#### 允许用户自定义元素大小(可拖拽拉伸)的属性   resize:both;</span><br></pre></td></tr></table></figure><p></p><p>font-family: ‘Open Sans’,Arial,Helvetica,sans-serif;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 实现双向绑定</span><br><span class="line"></span><br><span class="line">首先，Object的defineProperty和defineProperties这两个方法在js中的重要性十分重要，主要功能就是用来定义或修改这些内部属性,与之相对应的getOwnPropertyDescriptor和getOwnPropertyDescriptors就是获取这行内部属性的描述。</span><br><span class="line"></span><br><span class="line">##### 创建/修改/获取属性的方法</span><br></pre></td></tr></table></figure></p><p>Object.defineProperty()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">功能:</span><br><span class="line">方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。如果不指定configurable, writable, enumerable ，则这些属性默认值为false，如果不指定value, get, set，则这些属性默认值为undefined</span><br></pre></td></tr></table></figure></p><p>语法：Object.defineProperty(obj,prop,descriptor)<br>obj：需要被操作的目标对象；<br>prop：目标对象需要定义或修改的属性名称<br>descriptor：将被定义或修改的属性描述符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">var obj = new Object();</span><br><span class="line">Object.defineProperty(obj,&apos;name&apos;,&#123;</span><br><span class="line">    configurable:false,</span><br><span class="line">    writable:true,</span><br><span class="line">    enumberable:true,</span><br><span class="line">    value:&apos;Leila&apos;</span><br><span class="line">&#125;);</span><br><span class="line">console.log(obj.name)  // Leila</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperties</span><br></pre></td></tr></table></figure><p>功能：方法直接在一个对象定义一个或多个新的属性或者修改现有的属性，并返回该对象</p><p>语法：Object.defineProperties(obj,props);<br>obj:将要被添加属性或修改属性的对象；<br>props：该对象的一个或多个键值对定义了将要为对象添加或者修改的属性的具体配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var obj = new Object();</span><br><span class="line">Object.definePeoperties(obj,props,&#123;</span><br><span class="line">    name:&#123;</span><br><span class="line">        configurable:false,</span><br><span class="line">        enumerable:true,</span><br><span class="line">        writable:true,</span><br><span class="line">        value:&apos;Leila&apos;</span><br><span class="line">    &#125;,</span><br><span class="line">    age:&#123;</span><br><span class="line">        value:18,</span><br><span class="line">        conbfigurable:true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">console.log(obj.name,obj.age)  //Leila , 18</span><br></pre></td></tr></table></figure></p><h5 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor()"></a>Object.getOwnPropertyDescriptor()</h5><p>功能：该方法返回的是一个指定对象上的自有属性对应的属性描述（自有属性指的是直接赋予该对象的属性，不需要从原型链上查找的属性）<br>语法：Object.getOwnPropertyPropertyDescriptor(obj,prop)<br>obj:需要查找的目标对象<br>prop：目标对象属性的名称<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name:&apos;zxl&apos;,</span><br><span class="line">    age:16</span><br><span class="line">&#125;</span><br><span class="line">var desc = Object.getOwnPropertyDescriptor(person,name);</span><br><span class="line">console.log(desc);</span><br><span class="line">结果：</span><br><span class="line">// &#123;</span><br><span class="line">//     configurable: true,</span><br><span class="line">//     enumerable: true,</span><br><span class="line">//     writable: true,</span><br><span class="line">//     value: &quot;张三&quot;</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure></p><h5 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h5><p>功能：指定对象所有自身属性的描述，如果没有自身属性，则返回空对象<br>语法：Object.getOwnPropertyDescriptors(obj);<br>obj：需要查找的目标对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name:&apos;张三&apos;,</span><br><span class="line">    age:14</span><br><span class="line">&#125;</span><br><span class="line">var desc = Object.getOwnPropertyDescriptors(person,&apos;name&apos;);</span><br><span class="line">console.log(desc);</span><br></pre></td></tr></table></figure></p><p>结果：<br><img src="http://oqt3f60vc.bkt.clouddn.com/getOwnPropertyDescriptors.png" alt=""></p><p>所以双向绑定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">  &lt;input type=&quot;text&quot; id=&quot;txt&quot;&gt;</span><br><span class="line">  &lt;p id=&quot;showTxt&quot;&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var obj = &#123;&#125;;</span><br><span class="line">Object.defineProperty(obj,&apos;txt&apos;,&#123;</span><br><span class="line">    get: function()&#123;</span><br><span class="line">        return obj</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function(newValue)&#123;</span><br><span class="line">        document.getElementById(&apos;txt&apos;).value = newValue;</span><br><span class="line">        document.getElementByI的(&apos;showId&apos;).innerHTML = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">document.addEventListener(&apos;keyup&apos;,function(e)&#123;</span><br><span class="line">    obj.txt = e.target.value</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;如何学习前端的&quot;&gt;&lt;a href=&quot;#如何学习前端的&quot; class=&quot;headerlink&quot; title=&quot;如何学习前端的&quot;&gt;&lt;/a&gt;如何学习前端的&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;js高级教程第三版，接下来就是做项目，接触一些框架，然后，就开始学习框架，以及个人对于框
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vue传参数params和query的区别</title>
    <link href="http://LeilaBlog.site/2018/03/09/vue%E4%BC%A0%E5%8F%82%E6%95%B0params%E5%92%8Cquery%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://LeilaBlog.site/2018/03/09/vue传参数params和query的区别/</id>
    <published>2018-03-09T09:31:25.000Z</published>
    <updated>2018-03-09T09:54:40.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vue-router如何传参"><a href="#Vue-router如何传参" class="headerlink" title="Vue router如何传参"></a>Vue router如何传参</h3><p>params、query是什么？</p><p>params：/router1/:id ，/router1/123，/router1/789 ,这里的id叫做params<br>query：/router1?id=123 ,/router1?id=456 ,这里的id叫做query。</p><p>路由界面：<br>router.js:</p><p>路由设置这里，当你使用params方法传参的时候，要在路由后面加参数名，并且传参的时候，参数名要跟路由后面设置的参数名对应。使用query方法，就没有这种限制，直接在跳转里面用就可以。</p><p>注意：如果路由上面不写参数，也是可以传过去的，但不会在url上面显示出你的参数，并且当你跳到别的页面或者刷新页面的时候参数会丢失（如下图所示），那依赖这个参数的http请求或者其他操作就会失败。（param就会造成这样的问题）</p><p>编程式导航跳转：</p><p>上面的router-link传参，也可以使用router文档里面的编程式导航来跳转传参。</p><p>this.$router.push({ name:’router1’,params: { id: status ,id2: status3},query: { queryId: status2 }});<br>//编程跳转写在一个函数里面，通过click等方法来触发</p><h3 id="params传参和query传参有什么区别："><a href="#params传参和query传参有什么区别：" class="headerlink" title="params传参和query传参有什么区别："></a>params传参和query传参有什么区别：</h3><p>1、用法上的<br>刚query要用path来引入，params要用name来引入，接收参数都是类似的，分别是this.$route.query.name和this.$route.params.name。</p><p>注意接收参数的时候，已经是$route而不是$router了哦！！</p><p>2、展示上的</p><p>query更加类似于我们ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示</p><p>query: <a href="http://localhost:8080/#/home/detail/order/65d5ad38d9038723d340d97b5921d1d7?id=65d5ad38d9038723d340d97b5921d1d7&amp;perPrice=3&amp;sum=2&amp;color=%E9%BB%84%E8%89%B2%E5%B0%8F%E7%B1%B3%E6%89%8B%E6%9C%BA&amp;size=L%E5%B0%8F%E7%B1%B3%E6%89%8B%E6%9C%BA&amp;maxCount=495" target="_blank" rel="noopener">http://localhost:8080/#/home/detail/order/65d5ad38d9038723d340d97b5921d1d7?id=65d5ad38d9038723d340d97b5921d1d7&amp;perPrice=3&amp;sum=2&amp;color=%E9%BB%84%E8%89%B2%E5%B0%8F%E7%B1%B3%E6%89%8B%E6%9C%BA&amp;size=L%E5%B0%8F%E7%B1%B3%E6%89%8B%E6%9C%BA&amp;maxCount=495</a></p><p>params：<a href="http://localhost:8080/#/PaySuccess" target="_blank" rel="noopener">http://localhost:8080/#/PaySuccess</a></p><p>3、params是路由的一部分,必须要有。query是拼接在url后面的参数，没有也没关系。</p><p>params一旦设置在路由，params就是路由的一部分，如果这个路由有params传参，但是在跳转的时候没有传这个参数，会导致跳转失败或者页面会没有内容。</p><p>4、params、query不设置也可以传参，params不设置的时候，刷新页面或者返回参数会丢失，这一点的在上面说过了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Vue-router如何传参&quot;&gt;&lt;a href=&quot;#Vue-router如何传参&quot; class=&quot;headerlink&quot; title=&quot;Vue router如何传参&quot;&gt;&lt;/a&gt;Vue router如何传参&lt;/h3&gt;&lt;p&gt;params、query是什么？&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="vuejs传参" scheme="http://LeilaBlog.site/categories/vuejs%E4%BC%A0%E5%8F%82/"/>
    
    
      <category term="vue传参query和param的区别" scheme="http://LeilaBlog.site/tags/vue%E4%BC%A0%E5%8F%82query%E5%92%8Cparam%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>es6新增实用方法汇总</title>
    <link href="http://LeilaBlog.site/2018/02/28/es6%E6%96%B0%E5%A2%9E%E5%AE%9E%E7%94%A8%E6%96%B9%E6%B3%95%E6%B1%87%E6%80%BB/"/>
    <id>http://LeilaBlog.site/2018/02/28/es6新增实用方法汇总/</id>
    <published>2018-02-28T03:21:20.000Z</published>
    <updated>2018-04-23T09:57:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><ol><li>map()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4].map(function(item, index, array)&#123;</span><br><span class="line"></span><br><span class="line">　　return  item * 2;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>对数组中的每一项执行一次回调函数，三个参数依次为：数组中的每一项、每一项的下标、原数组。</p><p>map方法会改变原数组。</p><ol start="2"><li>filter()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1,22,3,14].filter(function(item, index, array)&#123;</span><br><span class="line"></span><br><span class="line">　　return  item &gt;= 10;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>对数组中的每一项执行一次回调函数，三个参数依次为：数组中的每一项、每一项的下标、原数组。</p><p>filter方法会新建一个数组存储满足条件的项，不会改变原数组</p><ol start="3"><li>some()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var  result = [11, 13, 15, 17].some(function(item, index, array) &#123;</span><br><span class="line"></span><br><span class="line">　　return  (item &gt;= 20)  //判断数组中是否有大于等于20的项，只要有一个满足条件即返回true</span><br><span class="line"></span><br><span class="line">&#125;)</span><br><span class="line">返回的是布尔值 true false</span><br></pre></td></tr></table></figure></li></ol><p>4.every()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var  result = [11, 13, 15, 17].every(function(item, index, array) &#123;</span><br><span class="line"></span><br><span class="line">　　return  (item &gt;= 20)  //判断数组中的 ** 每一项 ** 是否大于等于20，只要有一个不满足条件即返回false</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>5.lastIndexOf()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var  index = [2,3,4,2].lastIndexOf(&apos;2&apos;);  //index = 3</span><br></pre></td></tr></table></figure></p><p>返回给定项在数组中最后一次出现的位置</p><p>6.reduce()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var  sum = [1,2,3,4].reduce(function(result, current, index, array) &#123;</span><br><span class="line"></span><br><span class="line">　　return   result + current;   //10　</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>对数组元素按照给定的规则累积运算,result为每次得到的结果，current为当前值</p><p>7.of()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　Array.of(1,2,3)   //输出[1,2,3]</span><br></pre></td></tr></table></figure></p><p>8.from()  将类数组转化为数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　常用去重 Array.from(new Set([1,2,2,1,4,3,5,3]))  //输出[1,2,3,4,5]</span><br></pre></td></tr></table></figure></p><p>9.fill()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　[0,0,0].fill(11, 1)    //输出[0,11,11]</span><br></pre></td></tr></table></figure></p><p>　　fill里面的第一个参数为填充的字符，第二个参数为起始填充下标</p><p>10.find()  用于找出第一个符合条件的数组成员,没有符合条件的成员则返回undefined<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　[&quot;a&quot;,&quot;2&quot;,&quot;b&quot;].find((item)=&gt; item == &quot;2&quot;)</span><br><span class="line"></span><br><span class="line">结果为: &quot;2&quot;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">　　[&quot;a&quot;,&quot;2&quot;,&quot;b&quot;].find((item)=&gt; item == &quot;66&quot;)</span><br><span class="line"></span><br><span class="line">结果为: &quot;undefined&quot;</span><br></pre></td></tr></table></figure><p>　　接收一个回调函数，数组的每一项都会执行该回调，参数依次为当前项、当前项下标、原数组</p><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><ol><li>assign()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　var  obj1 = &#123;&quot;name&quot;: &quot;yzf&quot;&#125;</span><br><span class="line"></span><br><span class="line">　　var  obj2 = &#123;&quot;age&quot;: &quot;26&quot;&#125;</span><br><span class="line"></span><br><span class="line">　　var obj = Object.assign(obj1,obj2)   //输出&#123;&quot;name&quot;: &quot;yzf&quot;,&quot;age&quot;: &quot;26&quot;&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var  obj1 = &#123;&quot;name&quot;: &quot;yzf&quot;&#125;</span><br><span class="line">var  obj2 = &#123;&quot;age&quot;: &quot;26&quot;&#125;</span><br><span class="line">var  obj = Object.assign(obj1,obj2) </span><br><span class="line">console.log(obj)</span><br><span class="line">结果为：=&gt; &#123;name: &quot;yzf&quot;, age: &quot;26&quot;&#125;</span><br></pre></td></tr></table></figure><p>####<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;</span><br><span class="line">    var tmp = ...;</span><br><span class="line">    ...</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    let tmp = ...;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数声明语句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let a = &apos;secret&apos;;</span><br><span class="line">    function f()&#123;</span><br><span class="line">        return a;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数表达式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    let a = &quot;secret&quot;;</span><br><span class="line">    let f = function()&#123;</span><br><span class="line">        return a</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将对象彻底冻结的函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var containze = (obj) =&gt; &#123;</span><br><span class="line">    Object.freeze(obj);</span><br><span class="line">    Object.keys(obj).forEach((key,i) =&gt; &#123;</span><br><span class="line">        if( typeof obj[key] === &apos;object&apos;)&#123;</span><br><span class="line">            containze(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>6种声明变量的方法<br>var function  let const import class</p><p>顶层对象在浏览器环境指的window对象  在node环境中指的globald对象,ES5中顶层对象与全局变量是等价的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.a = 1;</span><br><span class="line">a //1</span><br><span class="line"></span><br><span class="line">a = 2</span><br><span class="line">window.a = 2;</span><br></pre></td></tr></table></figure></p><p>顶层对象的属性赋值与全局变量的赋值,是同一件事</p><p>顶层对象的属性与全局对象挂钩,被认为是js设计的最大败笔之一</p><p>ES6w为了改变这一点，var function 依旧是顶层对象属性 ，，let const class声明的全局变量不属于顶层对象的属性,，全局变量将和顶层对象属性脱钩<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = 1;</span><br><span class="line">this.a  // 1</span><br></pre></td></tr></table></figure></p><p>由var声明 是属于顶层对象的属性</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let b = 1;</span><br><span class="line">window.b //undefined</span><br></pre></td></tr></table></figure><p>由let声明，不属于顶层对象的属性，返回undefind</p><p>同一段代码，为了能够运行在不同的环境中都能取到顶层对象,一般使用this变量但是有局限性</p><p>全局环境中this会返回顶层对象，但是在node模块和ES6中this返回的是当前模块 </p><p>函数里面的this,如果函数不是作为对象的方法去运行,而是作为单纯的函数运行,this会指向顶层对象,但是严格模式下，this指向undefinded</p><p>不管是严格模式还是普通模式 new Function(‘return this’)()总会返回全局对象,那么eval newFunction这些方法都无法使用</p><h2 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h2><p>ES6允许按照一定的规则 从数组和对象中取值，对变量进行赋值，成为解构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let a = 1;</span><br><span class="line">let b = 2;</span><br><span class="line">let c = 3;</span><br></pre></td></tr></table></figure></p><p>ES6中，let [a,b,c] = [1,2,3]  这样从数组中提取值 然后对应位置，对变量赋值<br>解构不成功，变量的值等于undefinded</p><p>另一种不完全解构 即等号左边的模式只匹配一部分等号右边数组，这样的情况下，解构依然成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let [x,y] = [1,2,3];</span><br><span class="line">x // 1</span><br><span class="line">y // 2</span><br><span class="line"></span><br><span class="line">let [a,[b,c],d] = [1,[2],3]</span><br><span class="line">a // 1</span><br><span class="line">b // 2 </span><br><span class="line">d // 3</span><br></pre></td></tr></table></figure></p><p>如果等号右边不是数组那么将会报错</p><p>let [foo] = 1;<br>let [foo] = false;<br>let [foo] = NaN;<br>let [foo] = undefinded;<br>let [foo] = null;<br>let [foo] = {};</p><p>上面的语句都会报错，前四句转为对象以后不具备interator接口 最后一个本身不具备interator()迭代接口</p><p>对于set结构，也可使用数组解构赋值</p><p>let [x,y,z] = new set([‘a’,’b’,’c’])<br>x //‘a’</p><p>yield是用于generator函数，将形参绑定到实参的关键字，相当于return的最用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function*fibs()&#123;</span><br><span class="line">    let a = 0;</span><br><span class="line">    let b = 1;</span><br><span class="line">    while (true) &#123;</span><br><span class="line">        yield a;</span><br><span class="line">        [a,b] = [b,a+b];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let [first,second,third,fourth,fifth,sixth] = fibs();</span><br><span class="line">console.log(sixth); //5</span><br></pre></td></tr></table></figure><p>解构赋值允许使用默认值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let [foo = true] =  [];</span><br><span class="line">foo //true</span><br><span class="line"></span><br><span class="line">let [x,y = &apos;b&apos;] = [&apos;a&apos;];</span><br><span class="line">x=&apos;a&apos; y=&apos;b&apos;</span><br><span class="line"></span><br><span class="line">let [x,y = &apos;b&apos;] = [&apos;a&apos;,undefinded]</span><br><span class="line">x=&apos;a&apos;  y= &apos;b&apos;</span><br></pre></td></tr></table></figure></p><p>ES6内部使用严格的’===’判断一个位置是否有值,所以只有一个数组成员严格地等于”undefinded”时，默认值之才会生效</p><p>let [x = 1] = [undefinded]<br>x //1<br>let[x = 1] = [null]<br>x //null<br>如果数组成员是null默认值就不会生效，因为null不严格意义等于undefinded,</p><h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h3><p>解构不仅可以用于数组也可以用于对象</p><p>let {foo,bar} = {foo:’aaa’,bar:’bbb’}<br>foo // ‘aaa’<br>bar // ‘bbb’</p><p>对象解构与数组解构有重要的不同，数组主要取决于顺序和位置；而变量的属性没有次序，变量名必须与属性名一致，才能取到正确的值    </p><p>这就说明对象的解构赋值是下面这种形式的简写<br>let{foo:foo,bar:bar} = {foo:”aaa”,bar:”bbb”}<br>foo // “aaa”<br>bar // “bbb”</p><p>所以即对象解构赋值的内部机制是先找到同名属性，然后再赋值给对应的变量，真正被赋值的是后者而不是前者</p><p>错误的写法<br>let x;<br>{x} = {x:1}<br>因为js引擎会将其认为是一个代码块，会认为其实语法错误 </p><p>以下无意义的但也可以正确执行的解构赋值表达式<br>({} = [true,false])<br>({} = ‘abc’)<br>({} = [])</p><p>对象的解构赋值可以很轻易的将一个对象的方法，赋值到某个变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let &#123;log sin cos&#125; = Math;</span><br></pre></td></tr></table></figure><p>将Math对象的对数，正弦，余弦三个方法赋给对应变量，使用很方便<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr=[1,2,3];</span><br><span class="line">let &#123;0:first,[arr.length-1]:last&#125; = arr;</span><br><span class="line">first   //1</span><br><span class="line">last  //3</span><br></pre></td></tr></table></figure></p><p>上面对数组进行对象解构 数组的下标0对应的值是1；arr.length-1是2健其对应的值是3<br>方括号的这种写法属于“属性名表达式”</p><h3 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="headerlink" title="字符串的解构赋值"></a>字符串的解构赋值</h3><p>字符串也可以解构赋值 因为此时字符串转化成类似数组的对象，类似对象还有一个length属性<br>const [a,b,c,d,e] = ‘hello’;<br>a // h<br>以此类推<br>let [length:len] = ‘hello’;<br>len // 5        </p><h3 id="数值和布尔值解构赋值"><a href="#数值和布尔值解构赋值" class="headerlink" title="数值和布尔值解构赋值"></a>数值和布尔值解构赋值</h3><p>解构对象的规则是如果等号右边是数值或者布尔值先转为对象。</p><p>let {toString:s} = 123<br>s === Number.prototype.toString  // true</p><p>let {toString:s} = true<br>s === Boolean.prototype.tostring // true</p><p>字符串解构赋值的规则，右边要是不是数组或对象的话，先转化成对象<br>由于undefinded和null无法转化成对象，所以对他们进行解构赋值一般都会报错<br>let {prop:x} = undefinded·;  // Error<br>let {prop:y} = null ; // Error</p><h3 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="headerlink" title="函数参数的解构赋值"></a>函数参数的解构赋值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function add([x,y])&#123;</span><br><span class="line">    return x + y</span><br><span class="line">&#125;</span><br><span class="line">add([1,2]) //3</span><br></pre></td></tr></table></figure><p>[[1,2],[3,4]].map(([a,b]) =&gt; a+b);<br>a // 3<br>b // 7</p><p>undefinded会触发函数默认值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1,undefinded,3].map((x = &apos;yes&apos;) =&gt; x );</span><br><span class="line">// [1,&apos;yes&apos;,3]</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### 用途</span><br></pre></td></tr></table></figure></p><p>const map = new Map();<br>map.set(‘first’,’hello’);<br>map.set(‘second’,’world’);</p><p>for(let[key,value] of map){<br>    console.log(key + ‘ is ‘ + value);<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只想获取健名或者健值</span><br></pre></td></tr></table></figure></p><p>for(let [key] of map){</p><p>};</p><p>for( let [,value] of map ){</p><p>}<br><code>`</code></p><h3 id="字符串的遍历器接口"><a href="#字符串的遍历器接口" class="headerlink" title="字符串的遍历器接口"></a>字符串的遍历器接口</h3><p>for(let codePoint of ‘foo’){<br>    console.log(codePoint)<br>}<br>// ‘f’ ‘o’ ‘o’</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Array&quot;&gt;&lt;a href=&quot;#Array&quot; class=&quot;headerlink&quot; title=&quot;Array&quot;&gt;&lt;/a&gt;Array&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;map()&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>git常用命令</title>
    <link href="http://LeilaBlog.site/2018/02/27/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://LeilaBlog.site/2018/02/27/git常用命令/</id>
    <published>2018-02-27T09:18:32.000Z</published>
    <updated>2018-02-27T09:25:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用git前需要先了解git管理流程，主要涉及到以下几个概念："><a href="#使用git前需要先了解git管理流程，主要涉及到以下几个概念：" class="headerlink" title="使用git前需要先了解git管理流程，主要涉及到以下几个概念："></a>使用git前需要先了解git管理流程，主要涉及到以下几个概念：</h2><p>　　1.工作区 ：        编写代码的地方</p><p>　　2.暂存区 ：        执行git  add 命令后文件所去的地方</p><p>　　3.本地仓库 ：    执行git  commit  命令后文件所去的地方</p><p>　　4.远程仓库 ：    执行git  push  命令后文件所去的地方   </p><h3 id="一-查看分支"><a href="#一-查看分支" class="headerlink" title="一. 查看分支"></a>一. 查看分支</h3><p>　　1.git  branch   查看所有本地分支</p><p>　　2.git  branch -r  查看所有远程分支</p><p>　　3.git  branch -a  查看所有分支（本地+远程）</p><h3 id="二-切换分支"><a href="#二-切换分支" class="headerlink" title="二.切换分支"></a>二.切换分支</h3><p>　　1.git  checkout  ‘分支名’    切换到已存在的某个分支</p><p>　　2.git  checkout  -b ‘分支名’   ‘远程分支名’    基于某个远程分支创建一个新分支并切换</p><h3 id="三-删除分支"><a href="#三-删除分支" class="headerlink" title="三.删除分支"></a>三.删除分支</h3><p>　　1.git  branch  -D ‘分支名’    删除分支</p><h3 id="四-补丁应用"><a href="#四-补丁应用" class="headerlink" title="四.补丁应用"></a>四.补丁应用</h3><p>　　第一步：git   add  ‘修改的文件’</p><p>　　第二部：git   commit  -m  “补丁名称”</p><p>　　第三步：git   format-patch  -M  ‘对比分支名’    如：”git  format-patch -M  master”  与master分支对比</p><p>　　第四步：git   checkout   master  切换到需要应用补丁的分支</p><p>　　第五步：git   am  补丁名称.patch   通过git  am命令应用补丁  </p><h3 id="五-将本地项目推送到远程仓库"><a href="#五-将本地项目推送到远程仓库" class="headerlink" title="五.将本地项目推送到远程仓库"></a>五.将本地项目推送到远程仓库</h3><p>　　第一步：进入项目目录，执行git  init生成.git文件</p><p>　　第二步：git  remote  add origin “远程仓库地址”     添加远程仓库地址</p><p>　　第三步：git  add . </p><p>　　第四步：git  commit  -m  “备注信息”</p><p>　　第五步：git  push  origin  master  –force  </p><p>　</p><h2 id="Git基本常用命令如下："><a href="#Git基本常用命令如下：" class="headerlink" title="Git基本常用命令如下："></a>Git基本常用命令如下：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">git add XX        　　　　  把xx文件添加到暂存区去。</span><br><span class="line"></span><br><span class="line">git  reset  HEAD  &apos;xx&apos;        从暂存区删除git  add 的文件</span><br><span class="line"></span><br><span class="line">git commit –m “XX”  　　 提交文件 –m 后面的是注释。</span><br><span class="line"></span><br><span class="line">git status        　　　　　查看仓库状态</span><br><span class="line"></span><br><span class="line">git diff  XX      　　　　　查看XX文件修改了那些内容</span><br><span class="line"></span><br><span class="line">git log          　　　　　   查看历史记录</span><br><span class="line"></span><br><span class="line">git reset  –hard HEAD^ 或者 git reset  –hard HEAD~   回退到上一个版本</span><br><span class="line"></span><br><span class="line">                     (如果想回退到100个版本，使用git reset –hard HEAD~100 )</span><br><span class="line"></span><br><span class="line">cat XX         　　　　　  查看XX文件内容</span><br><span class="line"></span><br><span class="line">git reflog                          查看历史记录的版本号id</span><br><span class="line"></span><br><span class="line">git checkout — XX          把XX文件在工作区的修改全部撤销。</span><br><span class="line"></span><br><span class="line">git rm XX                         删除XX文件</span><br><span class="line"></span><br><span class="line">git remote add origin      关联一个远程库</span><br><span class="line"></span><br><span class="line">git push –u(第一次要用-u 以后不需要) origin master     把当前master分支推送到远程库</span><br><span class="line"></span><br><span class="line">git checkout –b dev       创建dev分支 并切换到dev分支上</span><br><span class="line"></span><br><span class="line">git branch  　　　　　  查看当前所有的分支</span><br><span class="line"></span><br><span class="line">git merge dev                在当前的分支上合并dev分支</span><br><span class="line"></span><br><span class="line">git branch –d dev          删除dev分支</span><br><span class="line"></span><br><span class="line">git branch name  　　   创建分支</span><br><span class="line"></span><br><span class="line">git stash  save   &apos;备注信息&apos;　     把工作区修改保存到暂存区</span><br><span class="line"></span><br><span class="line">git stash list 　　　　                 查看所有暂存区的文件列表</span><br><span class="line"></span><br><span class="line">git stash apply 　　      从暂存区恢复工作区的内容</span><br><span class="line"></span><br><span class="line">git stash drop　　　　 删除暂存区的内容</span><br><span class="line"></span><br><span class="line">git stash pop [--index]   [&lt;stash&gt;]　　  </span><br><span class="line"></span><br><span class="line">　　  从暂存区恢复工作区的内容，并删除暂存区的内容，</span><br><span class="line"></span><br><span class="line">　　 加上--index  不仅恢复工作区、还能恢复暂存区  </span><br><span class="line"></span><br><span class="line">     stash指定具体的进度</span><br><span class="line"></span><br><span class="line"> eg: git  stash pop --index  stash@&#123;0&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">git remote                      查看远程库的信息</span><br><span class="line"></span><br><span class="line">git remote –v 　　　　  查看远程库的详细信息</span><br><span class="line"></span><br><span class="line">　 git  format--patch         基于某个commit打补丁(需指定一个对比分支)　</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">git update-index --assume-unchanged  /path/to/file       #忽略跟踪 </span><br><span class="line"></span><br><span class="line">git update-index --no-assume-unchanged  /path/to/file  #恢复跟踪</span><br></pre></td></tr></table></figure><h3 id="git-tag打标签"><a href="#git-tag打标签" class="headerlink" title="git  tag打标签"></a>git  tag打标签</h3><p>　　　git标签分为两种，一种是轻量标签、一种是附注标签（推荐）。轻量标签是指向提交对象的引用。附注标签则是仓库中的一个独立对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">　　　git  tag  v1.0.0.2  -light           打一个轻量标签</span><br><span class="line"></span><br><span class="line">　　　git  tag  -a   v1.0.0.2  -m  &quot;v1.0.0.2版本&quot;            打一个附注标签</span><br><span class="line"></span><br><span class="line">　　　git push origin v0.1.2       将v0.1.2标签提交到git服务器</span><br><span class="line">　　　git push origin –tags        将本地所有标签一次性提交到git服务器</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;使用git前需要先了解git管理流程，主要涉及到以下几个概念：&quot;&gt;&lt;a href=&quot;#使用git前需要先了解git管理流程，主要涉及到以下几个概念：&quot; class=&quot;headerlink&quot; title=&quot;使用git前需要先了解git管理流程，主要涉及到以下几个概念
      
    
    </summary>
    
      <category term="git 版本管理" scheme="http://LeilaBlog.site/categories/git-%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="git 版本管理" scheme="http://LeilaBlog.site/tags/git-%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>vue补充</title>
    <link href="http://LeilaBlog.site/2018/02/26/vue%E8%A1%A5%E5%85%85/"/>
    <id>http://LeilaBlog.site/2018/02/26/vue补充/</id>
    <published>2018-02-26T02:09:25.000Z</published>
    <updated>2018-02-27T03:54:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="跳转页面的时候title跟着变化"><a href="#跳转页面的时候title跟着变化" class="headerlink" title="跳转页面的时候title跟着变化"></a>跳转页面的时候title跟着变化</h3><p>(并且让手机页面的title标题变化)</p><ol><li><p>修改vue单页面的title</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">created()&#123;</span><br><span class="line">    document.title = &apos;商品详情&apos;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">document.title=&quot;xxx&quot;来动态改变</span><br></pre></td></tr></table></figure></li><li><p>对于ios单页路由发生变化不加载的话他就不会变化所以<br>每个单页面写上created函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">documen.title = &apos;xxxx&apos;</span><br></pre></td></tr></table></figure></li></ol><p>并且要在comment.js里面写上以下函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function changeTitle(title)&#123;</span><br><span class="line">    document.title = title;</span><br><span class="line">    var mobile = navigator.userAgent.toLowerCase();</span><br><span class="line">    if (/iphone|ipad|ipod/.test(mobile)) &#123;</span><br><span class="line">        var iframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line">        iframe.style.display = &apos;none&apos;</span><br><span class="line">        var iframeCallback = function () &#123;</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">            iframe.removeEventListener(&apos;load&apos;, iframeCallback);</span><br><span class="line">            document.body.removeChild(iframe);</span><br><span class="line">        &#125;, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        iframe.addEventListener(&apos;load&apos;, iframeCallback);</span><br><span class="line">        document.body.appendChild(iframe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此段模拟load加载为了让ios获取页面加载从而才能改变title</p><p>2与下面的3本质是一样的，但是<br>2不够优雅的一点是将页面跳转title变化写在单页面里，为了更加项目代码的优雅性<br>所以采用第三种方案</p><h3 id="3-在common-js里面写上模拟加载函数"><a href="#3-在common-js里面写上模拟加载函数" class="headerlink" title="3. 在common.js里面写上模拟加载函数"></a>3. 在common.js里面写上模拟加载函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function changeTitle(title)&#123;</span><br><span class="line">    document.title = title;</span><br><span class="line">    var mobile = navigator.userAgent.toLowerCase();</span><br><span class="line">    if (/iphone|ipad|ipod/.test(mobile)) &#123;</span><br><span class="line">        var iframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line">        iframe.style.display = &apos;none&apos;</span><br><span class="line">        var iframeCallback = function () &#123;</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">            iframe.removeEventListener(&apos;load&apos;, iframeCallback);</span><br><span class="line">            document.body.removeChild(iframe);</span><br><span class="line">        &#125;, 0);</span><br><span class="line">        &#125;</span><br><span class="line">        iframe.addEventListener(&apos;load&apos;, iframeCallback);</span><br><span class="line">        document.body.appendChild(iframe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在router文件的index.js里面</p><h4 id="路由配置-每个要发生变化title的路径都写上对应的meta"><a href="#路由配置-每个要发生变化title的路径都写上对应的meta" class="headerlink" title="路由配置  每个要发生变化title的路径都写上对应的meta"></a>路由配置  每个要发生变化title的路径都写上对应的meta</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">routes: [</span><br><span class="line">    &#123;</span><br><span class="line">        name:&apos;home&apos;,</span><br><span class="line">        path: &apos;/home/:openname&apos;,</span><br><span class="line">        component: Home,</span><br><span class="line">        &lt;!-- 写上这个meta，这样就定义了title标签了 --&gt;</span><br><span class="line">        meta: &#123;</span><br><span class="line">           title: &apos;首页&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure><p>下面再加上变化监测</p><p>主要代码（这只是思路）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">  /* 路由发生变化修改页面title */</span><br><span class="line">  if (to.meta.title) &#123;</span><br><span class="line">    document.title = to.meta.title;</span><br><span class="line">  &#125;</span><br><span class="line">  next();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>为了让title标签变化方法要结合load方法（只有这样iphone才能监测从而改变title）故而项目中实际写的为下面这段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach((to, from, next) =&gt; &#123;</span><br><span class="line">    /* 路由发生变化修改页面title */</span><br><span class="line">    if (to.meta.title) &#123;</span><br><span class="line">      changeTitle(to.meta.title);</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">        changeTitle(&quot;积分商城&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>OK！优雅解决title随页面切换的问题</p><p>所谓优雅是每个单页面上只有功能性代码，其他的页面跳转路由，某个路由所展示哪个模块，title的变化都写在router里面了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;跳转页面的时候title跟着变化&quot;&gt;&lt;a href=&quot;#跳转页面的时候title跟着变化&quot; class=&quot;headerlink&quot; title=&quot;跳转页面的时候title跟着变化&quot;&gt;&lt;/a&gt;跳转页面的时候title跟着变化&lt;/h3&gt;&lt;p&gt;(并且让手机页面的title
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>事件委托</title>
    <link href="http://LeilaBlog.site/2018/02/05/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98/"/>
    <id>http://LeilaBlog.site/2018/02/05/事件委托/</id>
    <published>2018-02-05T06:33:40.000Z</published>
    <updated>2018-02-05T09:22:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://oqt3f60vc.bkt.clouddn.com/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98.webp" alt="banner"></p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><p>通俗地来讲，就是把一个元素响应事件（click、keydown……）的函数委托到另一个元素；<br>一般来讲，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，当事件响应到需要绑定的元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数；<br>举个例子，比如一个宿舍的同学同时快递到了，一种方法就是他们都傻傻地一个个去领取，还有一种方法就是把这件事情委托给宿舍长，让一个人出去拿好所有快递，然后再根据收件人一一分发给每个宿舍同学；<br>在这里，取快递就是一个事件，每个同学指的是需要响应事件的 DOM 元素，而出去统一领取快递的宿舍长就是代理的元素，所以真正绑定事件的是这个元素，按照收件人分发快递的过程就是在事件执行中，需要判断当前响应的事件应该匹配到被代理元素中的哪一个或者哪几个。</p><h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><p>前面提到 DOM 中事件委托的实现是利用事件冒泡的机制，那么事件冒泡是什么呢？</p><p>在 document.addEventListener 的时候我们可以设置事件模型：事件冒泡、事件捕获，一般来说都是用事件冒泡的模型；</p><p><img src="http://oqt3f60vc.bkt.clouddn.com/%E6%97%B6%E9%97%B4%E5%86%92%E6%B3%A1.webp" alt=""><br>如上图所示，事件模型是指分为三个阶段：</p><p>捕获阶段：在事件冒泡的模型中，捕获阶段不会响应任何事件；<br>目标阶段：目标阶段就是指事件响应到触发事件的最底层元素上；<br>冒泡阶段：冒泡阶段就是事件的触发响应会从最底层目标一层层地向外到最外层（根节点），事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层；</p><p>事件委托的优点</p><ol><li>减少内存消耗<br>试想一下，若我们有一个列表，列表之中有大量的列表项，我们需要在点击列表项的时候响应一个事件；<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;list&quot;&gt;</span><br><span class="line">  &lt;li&gt;item 1&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;item 2&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;item 3&lt;/li&gt;</span><br><span class="line">  ......</span><br><span class="line">  &lt;li&gt;item n&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">// ...... 代表中间还有未知数个 li</span><br></pre></td></tr></table></figure></li></ol><p>如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的，效率上需要消耗很多性能；<br>因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 ul 上，然后在执行事件的时候再去匹配判断目标元素；<br>所以事件委托可以减少大量的内存消耗，节约效率。</p><ol start="2"><li>动态绑定事件<br>比如上述的例子中列表项就几个，我们给每个列表项都绑定了事件；<br>在很多时候，我们需要通过 AJAX 或者用户操作动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件；<br>如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的；<br>所以使用事件在动态绑定事件的情况下是可以减少很多重复工作的。</li></ol><h4 id="jQuery-中的事件委托"><a href="#jQuery-中的事件委托" class="headerlink" title="jQuery 中的事件委托"></a>jQuery 中的事件委托</h4><p>jQuery 中的事件委托相信很多人都用过，它主要这几种方法来实现：</p><p>$.on: 基本用法: $(‘.parent’).on(‘click’, ‘a’, function () { console.log(‘click event on tag a’); })，它是 ‘.parent’ 元素之下的 a 元素的事件代理到 $(‘.parent’) 之上，只要在这个元素上有点击事件，就会自动寻找到 .parent 元素下的 a 元素，然后响应事件；</p><p>$.delegate: 基本用法: $(‘.parent’).delegate(‘a’, ‘click’, function () { console.log(‘click event on tag a’); })，同上，并且还有相对应的 $.delegate 来删除代理的事件；</p><p>/<em><br>$.live: 基本使用方法: $(‘a’, $(‘.parent’)).live(‘click’, function () { console.log(‘click event on tag a’); })，同上，然而如果没有传入父层元素 $(.parent)，那事件会默认委托到 $(document) 上；(已废除)</em>/</p><h4 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h4><p>基本实现<br>比如我们有这样的一个 HTML 片段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;list&quot;&gt;</span><br><span class="line">  &lt;li&gt;item 1&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;item 2&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;item 3&lt;/li&gt;</span><br><span class="line">  ......</span><br><span class="line">  &lt;li&gt;item n&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">// ...... 代表中间还有未知数个 li</span><br></pre></td></tr></table></figure></p><p>我们来实现把 #list 下的 li 元素的事件代理委托到它的父层元素也就是 #list 上：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 给父层元素绑定事件</span><br><span class="line">document.getElementById(&apos;list&apos;).addEventListener(&apos;click&apos;, function (e) &#123;</span><br><span class="line">  // 兼容性处理</span><br><span class="line">  var event = e || window.event;</span><br><span class="line">  var target = event.target || event.srcElement;</span><br><span class="line">  // 判断是否匹配目标元素</span><br><span class="line">  if (target.nodeName.toLocaleLowerCase === &apos;li&apos;) &#123;</span><br><span class="line">    console.log(&apos;the content is: &apos;, target.innerHTML);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>target.nodeName（当前点击的元素的节点名字）.toLocaleLowerCase（转化成小写） === 获得的即为你当前所点击的节点名称<br>target.innerHTML  当前你所点击的节点文本内容</p><p>在上述代码中， target 元素则是在 #list 元素之下具体被点击的元素，然后通过判断 target 的一些属性（比如：nodeName，id 等等）可以更精确地匹配到某一类 #list li 元素之上；</p><h4 id="使用-Element-matches-精确匹配"><a href="#使用-Element-matches-精确匹配" class="headerlink" title="使用 Element.matches 精确匹配"></a>使用 Element.matches 精确匹配</h4><p>如果改变下 HTML 成：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;list&quot;&gt;</span><br><span class="line">  &lt;li className=&quot;class-1&quot;&gt;item 1&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;item 2&lt;/li&gt;</span><br><span class="line">  &lt;li className=&quot;class-1&quot;&gt;item 3&lt;/li&gt;</span><br><span class="line">  ......</span><br><span class="line">  &lt;li&gt;item n&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">// ...... 代表中间还有未知数个 li</span><br></pre></td></tr></table></figure></p><p>这里，我们想把 #list 元素下的 li 元素（并且它的 class 为 class-1）的点击事件委托代理到 #list 之上；<br>如果通过上述的方法我们还需要在 if (target.nodeName.toLocaleLowerCase === ‘li’) 判断之中在加入一个判断 target.nodeName.className === ‘class-1’；<br>但是如果想像 CSS 选择其般做更加灵活的匹配的话，上面的判断未免就太多了，并且很难做到灵活性，这里可以使用 Element.matches API 来匹配；<br>Element.matches API 的基本使用方法: Element.matches(selectorString)，selectorString 既是 CSS 那样的选择器规则，比如本例中可以使用 target.matches(‘li.class-1’)，他会返回一个布尔值，如果 target 元素是标签 li 并且它的类是 class-1 ，那么就会返回 true，否则返回 false；<br>当然它的兼容性还有一些问题，需要 IE9 及以上的现代化浏览器版本；我们可以使用 Polyfill 来解决兼容性上的问题：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">if (!Element.prototype.matches) &#123;</span><br><span class="line">  Element.prototype.matches =</span><br><span class="line">    Element.prototype.matchesSelector ||</span><br><span class="line">    Element.prototype.mozMatchesSelector ||</span><br><span class="line">    Element.prototype.msMatchesSelector ||</span><br><span class="line">    Element.prototype.oMatchesSelector ||</span><br><span class="line">    Element.prototype.webkitMatchesSelector ||</span><br><span class="line">    function(s) &#123;</span><br><span class="line">      var matches = (this.document || this.ownerDocument).querySelectorAll(s),</span><br><span class="line">      i = matches.length;</span><br><span class="line">      while (--i &gt;= 0 &amp;&amp; matches.item(i) !== this) &#123;&#125;</span><br><span class="line">      return i &gt; -1;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;加上 Element.matches 之后就可以来实现我们的需求了：</span><br><span class="line">if (!Element.prototype.matches) &#123;</span><br><span class="line">  Element.prototype.matches =</span><br><span class="line">    Element.prototype.matchesSelector ||</span><br><span class="line">    Element.prototype.mozMatchesSelector ||</span><br><span class="line">    Element.prototype.msMatchesSelector ||</span><br><span class="line">    Element.prototype.oMatchesSelector ||</span><br><span class="line">    Element.prototype.webkitMatchesSelector ||</span><br><span class="line">    function(s) &#123;</span><br><span class="line">      var matches = (this.document || this.ownerDocument).querySelectorAll(s),</span><br><span class="line">      i = matches.length;</span><br><span class="line">      while (--i &gt;= 0 &amp;&amp; matches.item(i) !== this) &#123;&#125;</span><br><span class="line">      return i &gt; -1;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line">document.getElementById(&apos;list&apos;).addEventListener(&apos;click&apos;, function (e) &#123;</span><br><span class="line">  // 兼容性处理</span><br><span class="line">  var event = e || window.event;</span><br><span class="line">  var target = event.target || event.srcElement;</span><br><span class="line">  if (target.matches(&apos;li.class-1&apos;)) &#123;</span><br><span class="line">    console.log(&apos;the content is: &apos;, target.innerHTML);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h4 id="函数封装"><a href="#函数封装" class="headerlink" title="函数封装"></a>函数封装</h4><p>在应对更多场景上我们可以把事件代理的功能封装成一个公用函数，这样就可以重复利用了。<br>结合上面的例子来实现一个函数 eventDelegate，它接受四个参数：</p><p>[String] 一个选择器字符串用于过滤需要实现代理的父层元素，既事件需要被真正绑定之上；<br>[String] 一个选择器字符串用于过滤触发事件的选择器元素的后代，既我们需要被代理事件的元素；<br>[String] 一个或多个用空格分隔的事件类型和可选的命名空间，如 “click” 或 “keydown.click” ;<br>[Function] 需要代理事件响应的函数；</p><p>这里就有几个关键点：</p><p>对于父层代理的元素可能有多个，需要一一绑定事件；<br>对于绑定的事件类型可能有多个，需要一一绑定事件；<br>在处理匹配被代理的元素之中需要考虑到兼容性问题；<br>在执行所绑定的函数的时候需要传入正确的参数以及考虑到 this 的问题；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">function eventDelegate (parentSelector, targetSelector, events, foo) &#123;</span><br><span class="line">  // 触发执行的函数</span><br><span class="line">  function triFunction (e) &#123;</span><br><span class="line">    // 兼容性处理</span><br><span class="line">    var event = e || window.event;</span><br><span class="line">    var target = event.target || event.srcElement;</span><br><span class="line">    // 处理 matches 的兼容性</span><br><span class="line">    if (!Element.prototype.matches) &#123;</span><br><span class="line">      Element.prototype.matches =</span><br><span class="line">        Element.prototype.matchesSelector ||</span><br><span class="line">        Element.prototype.mozMatchesSelector ||</span><br><span class="line">        Element.prototype.msMatchesSelector ||</span><br><span class="line">        Element.prototype.oMatchesSelector ||</span><br><span class="line">        Element.prototype.webkitMatchesSelector ||</span><br><span class="line">        function(s) &#123;</span><br><span class="line">          var matches = (this.document || this.ownerDocument).querySelectorAll(s),</span><br><span class="line">            i = matches.length;</span><br><span class="line">          while (--i &gt;= 0 &amp;&amp; matches.item(i) !== this) &#123;&#125;</span><br><span class="line">          return i &gt; -1;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    // 判断是否匹配到我们所需要的元素上</span><br><span class="line">    if (target.matches(targetSelector)) &#123;</span><br><span class="line">      // 执行绑定的函数，注意 this</span><br><span class="line">      foo.call(target, Array.prototype.slice.call(arguments));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 如果有多个事件的话需要全部一一绑定事件</span><br><span class="line">  events.split(&apos;.&apos;).forEach(function (evt) &#123;</span><br><span class="line">    // 多个父层元素的话也需要一一绑定</span><br><span class="line">    Array.prototype.slice.call(document.querySelectorAll(parentSelector)).forEach(function ($p) &#123;</span><br><span class="line">      $p.addEventListener(evt, triFunction);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h4><p>当被代理的元素不是目标元素的时候，既选择器 targetSelector 所指向的元素不是 event.target （事件目标阶段指向的元素）的时候，这时候就需要层层遍历 event.target 的 parentNode 去匹配 targetSelector 了，直到 parentSelector。<br>比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;list&quot;&gt;</span><br><span class="line">  &lt;li&gt;&lt;span&gt;item 1&lt;/span&gt;&lt;/li&gt;</span><br><span class="line">  &lt;li&gt;&lt;span&gt;item 2&lt;/span&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure></p><p>还是把 li 的事件代理到 #list 之上，但这时候会发现 event.target 指向的是 li span，因此需要层层遍历外层元素去匹配，直到到代理事件的函数，我们可以用 event.currentTarget 来获取到代理事件的函数；<br>完整函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">function eventDelegate (parentSelector, targetSelector, events, foo) &#123;</span><br><span class="line"></span><br><span class="line">  // 触发执行的函数</span><br><span class="line">  function triFunction (e) &#123;</span><br><span class="line">    // 兼容性处理</span><br><span class="line">    var event = e || window.event;</span><br><span class="line"></span><br><span class="line">    // 获取到目标阶段指向的元素</span><br><span class="line">    var target = event.target || event.srcElement;</span><br><span class="line"></span><br><span class="line">    // 获取到代理事件的函数</span><br><span class="line">    var currentTarget = event.currentTarget;</span><br><span class="line"></span><br><span class="line">    // 处理 matches 的兼容性</span><br><span class="line">    if (!Element.prototype.matches) &#123;</span><br><span class="line">      Element.prototype.matches =</span><br><span class="line">        Element.prototype.matchesSelector ||</span><br><span class="line">        Element.prototype.mozMatchesSelector ||</span><br><span class="line">        Element.prototype.msMatchesSelector ||</span><br><span class="line">        Element.prototype.oMatchesSelector ||</span><br><span class="line">        Element.prototype.webkitMatchesSelector ||</span><br><span class="line">        function(s) &#123;</span><br><span class="line">          var matches = (this.document || this.ownerDocument).querySelectorAll(s),</span><br><span class="line">            i = matches.length;</span><br><span class="line">          while (--i &gt;= 0 &amp;&amp; matches.item(i) !== this) &#123;&#125;</span><br><span class="line">          return i &gt; -1;            </span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 遍历外层并且匹配</span><br><span class="line">    while (target !== currentTarget) &#123;</span><br><span class="line">      // 判断是否匹配到我们所需要的元素上</span><br><span class="line">      if (target.matches(targetSelector)) &#123;</span><br><span class="line">        var sTarget = target;</span><br><span class="line">        // 执行绑定的函数，注意 this</span><br><span class="line">        foo.call(sTarget, Array.prototype.slice.call(arguments))</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      target = target.parentNode;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 如果有多个事件的话需要全部一一绑定事件</span><br><span class="line">  events.split(&apos;.&apos;).forEach(function (evt) &#123;</span><br><span class="line">    // 多个父层元素的话也需要一一绑定</span><br><span class="line">    Array.prototype.slice.call(document.querySelectorAll(parentSelector)).forEach(function ($p) &#123;</span><br><span class="line">      $p.addEventListener(evt, triFunction);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eventDelegate(&apos;#list&apos;, &apos;li&apos;, &apos;click&apos;, function () &#123; console.log(this); &#125;);点击后可以看到 console 出了 #list li 元素对象；</span><br></pre></td></tr></table></figure></p><h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><p>当然，事件委托也是有一定局限性的；<br>比如 focus、blur 之类的事件本身没有事件冒泡机制，所以无法委托；<br>mousemove、mouseout 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的；</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;http://oqt3f60vc.bkt.clouddn.com/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98.webp&quot; alt=&quot;banner&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; cla
      
    
    </summary>
    
    
      <category term="事件委托 JavaScript" scheme="http://LeilaBlog.site/tags/%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98-JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>书单要读</title>
    <link href="http://LeilaBlog.site/2018/01/11/bookList/"/>
    <id>http://LeilaBlog.site/2018/01/11/bookList/</id>
    <published>2018-01-11T02:24:49.000Z</published>
    <updated>2018-01-11T05:32:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h3><blockquote><p>不能因为现实的复杂而放弃梦想，也不能因为理想的遥远而放弃挑战<br>梦为努力浇了水 爱最背后往前推<br>有些朋友常是一闪而逝 就像路上的行人一样<br>生命中最大的浪费是不快乐，虽然我们不是女明星，但我们也要做比较漂亮的老百姓<br>List</p><ul><li>《活着》<br>没有比活着更美好的事情，也没有比活着更艰难的事情<br>人是为了活着本身而活着，而不是为了活着之外的任何事物所活着</li><li>《许三观卖血记》</li><li>《在细雨中呼喊》</li><li>《文化苦旅》一系列</li><li>《人间失格》</li><li>《月亮与六便士》</li><li>《浮生六记》</li><li>《我不喜欢这世界 我只喜欢你》</li><li>《窗边的小豆豆》</li><li>《查令十字路84号》</li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;导语&quot;&gt;&lt;a href=&quot;#导语&quot; class=&quot;headerlink&quot; title=&quot;导语&quot;&gt;&lt;/a&gt;导语&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;不能因为现实的复杂而放弃梦想，也不能因为理想的遥远而放弃挑战&lt;br&gt;梦为努力浇了水 爱最背后往前推&lt;br&gt;有些朋友
      
    
    </summary>
    
      <category term="book-movie-music" scheme="http://LeilaBlog.site/categories/book-movie-music/"/>
    
    
      <category term="曾经心水的书" scheme="http://LeilaBlog.site/tags/%E6%9B%BE%E7%BB%8F%E5%BF%83%E6%B0%B4%E7%9A%84%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>about--Vuejs心得</title>
    <link href="http://LeilaBlog.site/2017/11/27/about-Vuejs%E5%BF%83%E5%BE%97/"/>
    <id>http://LeilaBlog.site/2017/11/27/about-Vuejs心得/</id>
    <published>2017-11-27T05:07:57.000Z</published>
    <updated>2017-11-28T08:35:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="trim"><a href="#trim" class="headerlink" title=".trim"></a>.trim</h3><p>v-model.trim 去除输入框的空格</p><h3 id="input绑定数据"><a href="#input绑定数据" class="headerlink" title="input绑定数据"></a>input绑定数据</h3><ol><li>v-model 绑定用户去输入的数据</li><li>在绑定的input框中填充从后台接口获取的数据时,如何让他在别的输入框变化的时候不会重新覆盖输入框里的数据   坑：参考登陆时验证码captch所对应的captch_key案例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">   &lt;input type=&quot;hidden&quot; v-model=&quot;form.captcha_key&quot; id=&quot;captcha_key&quot; name=&quot;captcha_key&quot; value=&quot;&quot;/&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">js</span><br><span class="line">data () &#123;</span><br><span class="line">var captcha_key = parseInt(Math.random()*899999 + 100000);</span><br><span class="line">&#125;</span><br><span class="line">return&#123;</span><br><span class="line">captcha_key:captcha_key</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="父子传递数据-vue2-0父子组件以及非父子组件如何通信"><a href="#父子传递数据-vue2-0父子组件以及非父子组件如何通信" class="headerlink" title="父子传递数据   vue2.0父子组件以及非父子组件如何通信"></a>父子传递数据   vue2.0父子组件以及非父子组件如何通信</h3><p>1.父调用子的方法</p><p>父组件中(引进子组件)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;followSheet ref=&quot;profileA&quot;&gt;&lt;/followSheet&gt;</span><br><span class="line"></span><br><span class="line">js</span><br><span class="line"></span><br><span class="line">follow () &#123;</span><br><span class="line">  this.$refs.profileA.getData();</span><br><span class="line">  // 清空文本框里的值</span><br><span class="line">  this.$refs.profileA.clear();</span><br><span class="line">  this.followVisible = false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>子组件中(写上函数方法即可)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">getData ()&#123;</span><br><span class="line">  var apiurl = this.$http.defaults.baseURL + &apos;Sheet/followSheet&apos;;</span><br><span class="line">  var session_key = getCookie(&apos;session_key&apos;);</span><br><span class="line">  var param = &#123;</span><br><span class="line">    id: this.$route.params.id,</span><br><span class="line">    session_key : getCookie(&apos;session_key&apos;),</span><br><span class="line">    expect_time:formatDateTime(this.form.expect_time),</span><br><span class="line">    remark:this.form.remark,</span><br><span class="line">  &#125;;</span><br><span class="line">  param.sign = getSign(param);</span><br><span class="line">  this.$http.post(apiurl,param).then((response) =&gt; &#123;</span><br><span class="line">    var result = response.data;</span><br><span class="line">    console.log(result);</span><br><span class="line">    if(parseInt(result.code) === 200)&#123;</span><br><span class="line">      var obj = result.data;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">      this.$message.error(&apos;跟进失败&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).catch(function(error)&#123;</span><br><span class="line">    this.$message.error(error.message);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还有其他方法补充中。。。</p><p>子组件通过$emit触发父组件的事件，$emit后面的参数是向父组件传参，</p><ol start="2"><li>子调用父的方法</li></ol><ol start="3"><li>父组件传递数据给子组件<br>父组件数据如何传递给子组件呢？可以通过props属性来实现<br>父组件：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">  &lt;child :child-msg=&quot;msg&quot;&gt;&lt;/child&gt;//这里必须要用 - 代替驼峰</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"> </span><br><span class="line">data()&#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    msg: [1,2,3]</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>子组件通过props来接收数据:<br>方式1：props: [‘childMsg’]<br>方式2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  childMsg: Array //这样可以指定传入的类型，如果类型不对，会警告</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>方式3：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  childMsg: &#123;</span><br><span class="line">    type: Array,</span><br><span class="line">    default: [0,0,0] //这样可以指定默认的值</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样呢，就实现了父组件向子组件传递数据</p><p>4.子组件与父组件的通信</p><p>子组件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div @click=&quot;up&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"> </span><br><span class="line">methods: &#123;</span><br><span class="line">  up() &#123;</span><br><span class="line">    this.$emit(&apos;upup&apos;,&apos;hehe&apos;); //主动触发upup方法，&apos;hehe&apos;为向父组件传递的数据</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>父组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &lt;child @upup=&quot;change&quot; :msg=&quot;msg&quot;&gt;&lt;/child&gt; //监听子组件触发的upup事件,然后调用change方法</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">methods: &#123;</span><br><span class="line">  change(msg) &#123;</span><br><span class="line">    this.msg = msg;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="兄弟组件传递数据-XX-bus"><a href="#兄弟组件传递数据-XX-bus" class="headerlink" title="兄弟组件传递数据  XX bus"></a>兄弟组件传递数据  XX bus</h3><ol start="5"><li>非父子组件通信<br>如果2个组件不是父子组件那么如何通信呢？这时可以通过eventHub来实现通信.<br>所谓eventHub就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件.</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let Hub = new Vue(); //创建事件中心</span><br></pre></td></tr></table></figure><p>组件1触发：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div @click=&quot;eve&quot;&gt;&lt;/div&gt;</span><br><span class="line">methods: &#123;</span><br><span class="line">  eve() &#123;</span><br><span class="line">    Hub.$emit(&apos;change&apos;,&apos;hehe&apos;); //Hub触发事件</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>组件2接收:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;&lt;/div&gt;</span><br><span class="line">created() &#123;</span><br><span class="line">  Hub.$on(&apos;change&apos;, () =&gt; &#123; //Hub接收事件</span><br><span class="line">    this.msg = &apos;hehe&apos;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就实现了非父子组件之间的通信了.原理就是把Hub当作一个中转站！</p><ol><li>父子组件传递，父向子传递采用props，子向父采用事件emit</li><li>非父子组件的传递，全局Event bus，new一个vue的实例，采用事件的方式通信，再者采用vuex全局状态管理</li></ol><h3 id="常见问题汇总Q50个"><a href="#常见问题汇总Q50个" class="headerlink" title="常见问题汇总Q50个"></a>常见问题汇总Q50个</h3><p>Q1:data functions should return an object这个问题是 Vue 实例内,单组件的data必须返回一个对象;如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">export default &#123;</span><br><span class="line">  name: &apos;page-router-view&apos;,</span><br><span class="line">      data () &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        tabs: [</span><br><span class="line">          &#123;</span><br><span class="line">            title: &apos;财务信息&apos;,</span><br><span class="line">            url: &apos;/userinfo&apos;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            title: &apos;帐号信息&apos;,</span><br><span class="line">            url: &apos;/userinfo/base&apos;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为什么要 return 一个数据对象呢?<br>官方解释如下:  data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！<br>简言之,组件复用下,不会造成数据同时指向一处,造出牵一发而动全身的破问题…</p><p>Q2: 给组件内的原生控件添加事件,怎么不生效了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--比如用了第三方框架,或者一些封装的内置组件; 然后想绑定事件--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--// 错误例子1--&gt;</span><br><span class="line">&lt;el-input placeholder=&quot;请输入特定消费金额 &quot; @mouseover=&quot;test()&quot;&gt;&lt;/el-input&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!--// 错误例子2--&gt;</span><br><span class="line">&lt;router-link :to=&quot;item.menuUrl&quot; @click=&quot;toggleName=&apos;&apos;&quot;&gt;</span><br><span class="line">  &lt;i :class=&quot;[&apos;fzicon&apos;,item.menuIcon]&quot;&gt;&lt;/i&gt;</span><br><span class="line">  &lt;span&gt;&#123;&#123;item.menuName&#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;!--上面的两个例子都没法触发事件!!!--&gt;</span><br><span class="line">&lt;!--究其原因,少了一个修饰符 .native--&gt;</span><br><span class="line">&lt;router-link :to=&quot;item.menuUrl&quot; @click.native=&quot;toggleName=&apos;&apos;&quot;&gt;</span><br><span class="line">  &lt;i :class=&quot;[&apos;fzicon&apos;,item.menuIcon]&quot;&gt;&lt;/i&gt;</span><br><span class="line">  &lt;span&gt;&#123;&#123;item.menuName&#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;/router-link&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--明明官方文档有的,一堆人不愿意去看,,Fuck--&gt;</span><br><span class="line">&lt;!--https://cn.vuejs.org/v2/guide/components.html#给组件绑定原生事件--&gt;</span><br></pre></td></tr></table></figure></p><p>Q3: 用了 axios , 为什么 IE 浏览器不识别(IE9+)<br>IE 整个家族都不支持 promise, 解决方案:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install es6-promise</span><br><span class="line"></span><br><span class="line">// 在 main.js 引入即可</span><br><span class="line">// ES6的polyfill</span><br><span class="line">require(&quot;es6-promise&quot;).polyfill();</span><br></pre></td></tr></table></figure></p><p>Q4: 在函数内用了this.xxx=,为什么抛出Cannot set property ‘xxx’ of undefined;这又是this的套路了..this是和当前运行的上下文绑定的…<br>一般你在axios或者其他 promise , 或者setInterval 这些默认都是指向最外层的全局钩子.<br>简单点说:”最外层的上下文就是 window,vue内则是 Vue 对象而不是实例!”;<br>解决方案:</p><p>暂存法: 函数内先缓存 this , let that = this;(let是 es6, es5用 var)<br>箭头函数: 会强行关联当前运行区域为 this 的上下文;</p><p>this的知识, 读”&lt;&lt;你不知道的 JS 系列&gt;&gt;”最为合适了,里面讲的很清楚</p><p>Q5: @click.prevent,v-demo.a.b;就拿这两个例子来说吧.</p><p>@click.prevent : 事件+修饰符 , 作用就是点击但又阻止默认行为<br>v-demo.a.b: 自定义指令+修饰符. 具体看你什么指令了,修饰符的作用大多是给事件增加一些确切的拓展功能</p><p>比如阻止事件冒泡,阻止默认行为,访问到原生控件,结合键盘快捷键等等<br>传送门:<a href="https://cn.vuejs.org/v2/guide/events.html#事件修饰符" target="_blank" rel="noopener">事件修饰符</a>;<br>可以自定义修饰符么?也是可以的..<br>可以通过全局 config.keyCodes 对象自定义键值修饰符别名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 阻止单击事件继续传播 --&gt;</span><br><span class="line">&lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 提交事件不再重载页面 --&gt;</span><br><span class="line">&lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 修饰符可以串联 --&gt;</span><br><span class="line">&lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span><br><span class="line">&lt;!-- 即内部元素触发的事件先在此处处理，然后才交由内部元素自身进行处理 --&gt;</span><br><span class="line">&lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span><br><span class="line">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span><br><span class="line">&lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 点击事件将只会触发一次 --&gt;</span><br><span class="line">&lt;a v-on:click.once=&quot;doThis&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><p>Q6: 引入的小图片渲染出来却是 data:image/png;base64xxxxxxxx这个是 webpack 里面的对应插件处理的.<br>对于小于多少 K 以下的图片(规定的格式)直接转为 base64格式渲染;<br>具体配置在webpack.base.conf.js里面的 rules里面的 url-loader<br>这样做的好处:在网速不好的时候先于内容加载和减少http的请求次数来减少网站服务器的负担。</p><p>Q7: Component template shold contain exactly one root element.If you are useing v-if on multiple elements , xxxxx</p><p>大体就是说,单组件渲染 DOM 区域必须要有一个根元素,不能出现同级元素.可以用v-if和v-else-if指令来控制其他元素达到并存的状态<br>换个直白的解释,就是有一个唯一的父类,包裹者;</p><p>比如一个 div(父包含块) 内部多少个同级或者嵌套都行,但是最外层元素不能出现同级元素!!!!</p><p>这个坑纠结了好久的啊啊啊</p><p>Q8: 跨域问题怎么破!比如No ‘Access-Control-Allow-Origin’ header is present on the requested resource.这种问题老生常谈<br>1: CORS , 前后端都要对应去配置,IE10+<br>2: nginx 反向代理,一劳永逸  &lt;– 线上环境可以用这个<br>线下开发模式,比如你用了vue-cli, 里面的 webpack 有引入了proxyTable的东西,也可以做接口反向代理<br>// 在 config 目录下的index.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">proxyTable: &#123;</span><br><span class="line">  &quot;/bp-api&quot;: &#123;</span><br><span class="line">    target: &quot;http://new.d.st.cn&quot;,</span><br><span class="line">    changeOrigin: true,</span><br><span class="line">    // pathRewrite: &#123;</span><br><span class="line">    //   &quot;^/bp-api&quot;: &quot;/&quot;</span><br><span class="line">    // &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// target : 就是 api 的代理的实际路径</span><br><span class="line">// changeOrigin: 就是是变源,必须是...</span><br><span class="line">// pathRewrite : 就是路径重定向,一看就知道</span><br></pre></td></tr></table></figure></p><p>当然还有依旧坚挺的jsonp大法!不过局限性比较多,比较适合一些特殊的信息获取!</p><p>Q9: 我需要遍历的数组值更新了,值也赋值了,为什么视图不更新!!!那是因为有局限性啊,官方文档也说的很清楚,只有一些魔改的之后的方法提供跟原生一样的使用姿势(却又可以触发视图更新);<br>一般我们更常用(除了魔改方法)的手段是使用:this.$set(obj,item,value);<br>传送门:<a href="https://cn.vuejs.org/v2/guide/list.html#数组更新检测" target="_blank" rel="noopener">数组更新检测(触发视图更新)</a></p><p>Q10: 为什么我的组件间的样式不能继承或者覆写啊!!!单组件开发模式下,请确认是否开启了 CSS模块化功能!!<br>也就是 <strong> scoped </strong> (vue-cli 里面配置了,只要加入这个属性就自动启用)<br><code>&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt;</code><br>为什么不能继承或者覆写呢,那时因为每个类或者 id 乃至标签都会给自动在css后面添加hash!<br>比如<br>// 写的时候是这个<br><code>.trangle{}</code></p><p>// 编译过后,加上了 hash<br><code>.trangle[data-v-1ec35ffc]{}</code>这些都是在 css-loader 里面配置!!!<br>这样就相同的类名也不能继承了</p><p>Q11: 路由模式改为history后,除了首次启动首页没报错,刷新访问路由都报错!<br>必须给对应的服务端配置查询的主页面..也可以认为是主路由入口的引导<br>传送门 : <a href="https://router.vuejs.org/zh-cn/essentials/history-mode.html" target="_blank" rel="noopener">Vue-Router history Mode</a></p><p>Q12: 想拦截页面,或者在页面进来之前做一些事情,可以么?</p><p>Of course !!</p><p>各种路由器的钩子!! 传送门: <a href="https://router.vuejs.org/zh-cn/advanced/navigation-guards.html" target="_blank" rel="noopener">导航守卫</a>;</p><p>当然,记忆滚动的位置也可以做到,详情翻翻里面的文档</p><p>Q13: Uncaught ReferenceError: xxx is not define</p><ul><li>实例内的 data 对应的变量没有声明</li><li>你导入模块报这个错误,那是导出没写好</li></ul><p>Q14: Error in render function:”Type Error: Cannot read property ‘xxx’ of undefined”这种问题大多都是初始化的姿势不对;<br>比如引入echart这些…仔细去了解下生命周期,再来具体初始化;<br>vue 组件有时候也会(嵌套组件或者 props传递初始化)..也是基本这个问题</p><p>Q15: npm run build之后不能直接访问</p><p>最起码得在本地搭个服务器才能访问</p><p>Q16: CSS background 引入图片打包后,访问路径错误因为打包后图片是在根目录下,你用相对路径肯定报错啊….你可以魔改 webpack 的配置文件里面的static为./static…但是不建议<br>你若是把图片什么丢到assets目录下,然后相对路径,打包后是正常的</p><p>Q17: Unexpected tab charater这些</p><p>一般是你用脚手架初始化的时候开了 eslint ;</p><p>要么遵循规则,要么改变规则;</p><p>要么直接把 webpack 里面的 eslint 检测给关闭了 (安装的时候)</p><p>Q18: Failed to mount component: template or render function not defined</p><p>组件挂载失败,问题只有这么几个</p><ul><li>组件没有正确引入; </li><li>挂载点顺序错了了;</li></ul><p>Q19: Unknown custom element: <xxx> - did you register the component correctly?组件没有正确引入或者正确使用,依次确认</xxx></p><ul><li>写好组件</li><li>导入对应的组件</li><li>在 components 内声明</li><li>在 dom 区域声明标签</li></ul><p>Q20: axios的 post 请求后台接受不到!</p><p>axios默认是 json 格式提交,确认后台是否做了对应的支持;</p><p>若是只能接受传统的表单序列化,就需要自己写一个转义的方法…</p><p>当然还有一个更加省事的方案,装一个小模块qs<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">npm install qs -S</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 然后在对应的地方转就行了..单一请求也行,拦截器也行...我是写在拦截器的.</span><br><span class="line">// 具体可以看看我 axios 封装那篇文章</span><br><span class="line"></span><br><span class="line">//POST传参序列化(添加请求拦截器)</span><br><span class="line">Axios.interceptors.request.use(</span><br><span class="line">  config =&gt; &#123;</span><br><span class="line">    // 在发送请求之前做某件事</span><br><span class="line">    if (</span><br><span class="line">      config.method === &quot;post&quot;</span><br><span class="line">    ) &#123;</span><br><span class="line">      // 序列化</span><br><span class="line">      config.data = qs.stringify(config.data); // ***** 这里转义</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 若是有做鉴权token , 就给头部带上token</span><br><span class="line">    if (localStorage.token) &#123;</span><br><span class="line">      config.headers.Authorization = localStorage.token;</span><br><span class="line">    &#125;</span><br><span class="line">    return config;</span><br><span class="line">  &#125;,</span><br><span class="line">  error =&gt; &#123;</span><br><span class="line">    Message(&#123;</span><br><span class="line">      //  饿了么的消息弹窗组件,类似toast</span><br><span class="line">      showClose: true,</span><br><span class="line">      message: error,</span><br><span class="line">      type: &quot;error.data.error.message&quot;</span><br><span class="line">    &#125;);</span><br><span class="line">    return Promise.reject(error.data.error.message);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>Q21: Invalid prop: type check failed for prop “xxx”. Expected Boolean, got String.<br>这种问题一般就是组件内的 props 类型已经设置了接受的范围类型,而你传递的值却又不是它需要的类型</p><p>Q22: 过滤器可以用于DOM区域结合指令么?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 不行,看下面的错误例子</span><br><span class="line">&lt;li v-for=&quot;(item,index) in range | sortByDesc | spliceText&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/li&gt;</span><br><span class="line"></span><br><span class="line">// `vue2+`的指令只能用语 mustache`&#123;&#123;&#125;&#125;` , 正确姿势如下:</span><br><span class="line"></span><br><span class="line">&lt;span&gt;&#123;&#123; message | capitalize &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure></p><p>Q23: […Array],…mapState,[SOME_MUTATION] (state) {},increment ({ commit }) {}这种写法是???!</p><p>ES6+(ES2015)的基础啊啊..<br>上面依次:数组解构,对象解构,对象风格函数,对象解构赋值传递</p><p>Q24: Vue 网站为什么 UC 访问一片空白亦或者flex布局错乱!! emmmm…. UC 号称移动界的 IE 这称号不是白叫的</p><p>flexbox 布局错乱,一般是你没有把兼容方案写上..就是带各种前缀,复合属性拆分<br>看看这篇文章:<a href="http://blog.csdn.net/crper/article/details/51902681" target="_blank" rel="noopener">移动端爬坑记 — （1）布局与样式上的奇葩偶遇</a>, 最好就用插件来代替人力吧,,引入 autoprefixer, 写上兼容范围就好了.</p><p>UC访问空白, 有一种情况绝对会造成,那就是 ES6的代码降级不够彻底. 其他情况可能就是路由配置问题(自己去排除)<br>现在的开发都推荐按需引入,靠babel-preset-env 来控制,以达到打包体积减小.<br>但是这样做的后果,有些内核比较老的不适用emmm<br>所以最好把代码完全 ES5话!!记住有些特性不能乱使用,没有对应的 polyfill,比如 ES6 的proxy</p><p>Q24:this.$set | this.$xxx 这个 $ 是个什么意思?是 jQuery的么,会冲突么?  不会的！.<br>Vue 的$和 jQuery 的$并没有半毛钱的关系,就跟javascript和java一样.<br>Vue 的$是封装了一些 vue 的内建函数,然后导出以$开头…这显然并不是 jQuery的专利;<br>jQuery 的$是选择器!!取得 DOM区域…两者的作用完全不一致!</p><p>Q25 : 组件的通讯有哪几种啊!!!  上面详细有解释啦</p><p>基本最常用的是这三种;</p><p>父传子: props<br>子传父: emit<br>兄弟通讯:<br>event bus: 就是找一个中间组件来作为信息传递中介<br>vuex: 信息树<br>传送门:<br><a href="https://cn.vuejs.org/v2/guide/components.html" target="_blank" rel="noopener">基本通讯</a><br><a href="https://vuex.vuejs.org/zh-cn/intro.html" target="_blank" rel="noopener">Vuex</a></p><p>Q26: vuex的用户信息为什么还要存一遍在浏览器里(sessionStorage or localStorage)</p><p>因为 vuex的 store 不敌刷新啊.<br>保存在浏览器的缓存内,若用户刷新的话,值再取一遍;</p><p>Q27:线上若是 nginx,如何部署?以及反向代理这些!!</p><p>传送门:<a href="https://juejin.im/post/58bfc412da2f60124db5999a" target="_blank" rel="noopener">一篇不大靠谱的nginx 1.11.10配置文件</a></p><p>Q28: npm run dev 报端口错误!Error: listen EADDRINUSE :::8080<br>自己用 webpack搭脚手架的都不用说了;</p><p>Vue-cli 里面的 webpack 配置: config/index.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">dev: &#123;</span><br><span class="line">  env: require(&quot;./dev.env&quot;),</span><br><span class="line">  port: 8080, //  这里这里,若是这个端口已经给系统的其他程序占用了.改我改我!!!!!!</span><br><span class="line">  autoOpenBrowser: true,</span><br><span class="line">  assetsSubDirectory: &quot;static&quot;,</span><br><span class="line">  assetsPublicPath: &quot;/&quot;,</span><br><span class="line">  proxyTable: &#123;</span><br><span class="line">    &quot;/bp-api&quot;: &#123;</span><br><span class="line">      target: &quot;http://new.d.st.cn&quot;,</span><br><span class="line">      changeOrigin: true,</span><br><span class="line">      // pathRewrite: &#123;</span><br><span class="line">      //   &quot;^/bp-api&quot;: &quot;/&quot;</span><br><span class="line">      // &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p><p>Q29: 什么时候用v-if,什么用 v-show!我们先来说说两者的核心差异;</p><p>v-if : DOM 区域没有生成,没有插入文档..等条件成立的时候才动态插入到页面!<br>有些需要遍历的数组对象或者值,最好用这个控制,等到拿到值才处理遍历,不然一些操作过快的情况会报错,比如数据还没请求到!</p><p>v-show: DOM 区域在组件渲染的时候同时渲染了,只是单纯用 css 隐藏了（等同于 display:none）<br>对于下拉菜单,折叠菜单这些数据基本不怎么变动.用这个最合适了..而且可以改善用户体验,因为它不会导致页面的重绘,DOM 操作会! </p><p>简言之: DOM结构不怎么变化的用v-show, 数据需要改动很大或者布局改动的用v-if</p><p>Q30: <template>是什么,html5的标签么?<br>是的..html5的标签还真有这么一个.传送门:<a href="https://caniuse.com/#search=template" target="_blank" rel="noopener">Can I Use:template</a><br><strong> <a href="https://caniuse.com/" target="_blank" rel="noopener">查询h5标签是否可用</a> </strong><br>不过 Vue 的 template 有点不一样,不是去给浏览器解析的….你可以理解为一个临时标签,用来方便你写循环,判断的….因为最终 template 不会解析到浏览器的页面,他只是在 Vue 解析的过程充当一个包裹层!最终我们看到的是内部处理后的组合的 DOM 结构! enen就是这样子~~</template></p><p>Q31:the “scope” attribute for scoped slots …. replaced by “slot-scope” since 2.5<br>这个问题只出现老项目升级到 vue2.5+的时候, 提示就是 scope 现在要用 slot-scope 来代替,但是 scope 暂时可以用,以后会移除</p><p>Q32: Uncaught ReferenceError : Vue is not defined!</p><p>依次排除:</p><ul><li>Vue是否正确引入!</li><li>Vue是否正确实例化!</li><li>Vue 用的姿势是否正确(比如你直接一个 Vue 的变量!!!刚好又没定义,,具体问题具体分析吧)</li></ul><p>Q33: ERROR in static/js/xxxxxxx.js from UglifyJs我知道其中一种情况会报这种情况,就是你引入的 js,是直接引入压缩版本后的 js(xxx.min.js);然后 webpack 内又启用了 UglifyJs(压缩 JS的), 二重压缩大多都会报错!!<br>解决方案:引入标准未压缩的 JS</p><p>Q34:props不使用:(v-bind)可以传递值么!</p><p>可以,只是默认传递的类型会被解析成字符串!<br>若是要传递其他类型,该绑定还是绑定!!</p><p>Q35: Uncaught TypeError : Cannot set property xxx which has only a getter</p><p>这个问题就是你要操作的属性只允许 getter,不允许 setter;</p><p>Q36: 单组件中里面的 import xxx from ‘@/components/layout/xxx’中的@是什么!这是 webpack 方面的知识,<br>webpack可以配置alias(也就是路径别名), linux 或者 mac 都知道<br>依旧如上,会自己搭脚手架的不用我说了…看看 vue-cli 里面的;<br>文件名: build -&gt; webpack.base.conf.js</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">    extensions: [&quot;.js&quot;, &quot;.vue&quot;, &quot;.json&quot;], // 可以导入的时候忽略的拓展名范围</span><br><span class="line">    alias: &#123;</span><br><span class="line">      vue$: &quot;vue/dist/vue.esm.js&quot;,  </span><br><span class="line">      &quot;@&quot;: resolve(&quot;src&quot;),  // 这里就是别名了,比如@就代表直接从/src 下开始找起!!!</span><br><span class="line">      &quot;~&quot;: resolve(&quot;src/components&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><p>Q37: SCSS(SASS) 还是 less,stylus 好!!三者都是预处理器;<br>scss 出现最久,能做的功能比较多,但是若是普通的嵌套写法,继承,mixin 啊.<br>这三个都差不多..会其中一个其他两个的粗浅用法基本也会了.不过!!!!<br>写法有些差异:</p><ul><li>scss: 写法上是像 css 靠齐 </li><li>sass : 其实也就是 scss , 只是写法不一样…靠的是缩进</li><li>less : 跟 css 基本靠齐</li><li>stylus : 一样,靠缩进..跟pug(Jade)一样</li></ul><p>使用环境的差异:</p><ul><li>scss 可以借助 ruby 或者 node-sass 编译</li><li>less 可以用 less.js 或者对应的 loader 解析</li><li>stylus 只能借助 loader 解析,它的出现就是基于 node 的</li></ul><p>也有一个后起之秀,主打解耦,插件化的!!! 那就是PostCSS,这个是后处理器!!!</p><p>Q38:Failed to compile with x errors : This  dependency was not found !编译错误,对应的依赖没找到!!!<br>解决如下:</p><p>知道缺少对应的模块,直接装进去<br>若是一个你已经安装的大模块(比如 axios)里面的子模块(依赖包)出了问题,卸载重装整个大模块.因为你补全不一定有用!</p><p>Q39: 为什么我的 npm 或者 yarn 安装依赖会生成 lock文件,有什么用!lock 文件的作用是统一版本号,这对团队协作有很大的作用;<br>若是没有 lock 锁定,根据package.json里面的^,~这些..<br>不同人,不同时间安装出来的版本号不一定一致;<br>有些包甚至有一些breaking change(破坏性的更新),造成开发很难顺利进行!!!</p><p>Q40: 组件可以缓存么?可以,用keep-alive;<br>不过是有代码的..占有内存会多了…所以无脑的缓存所有组件!!!别说性能好了..切换几次,有些硬件 hold不住的,浏览器直接崩溃或者卡死..<br>所以keep-alive一般缓存都是一些列表页,不会有太多的操作,更多的只是结果集的更换..<br>给路由的组件meta增加一个标志位,结合v-if就可以按需加上缓存了</p><p>Q41:package.json里面的dependencies 和devDependencies的差异!其实不严格的话,没有特别的差异;若是严格,遵循官方的理解;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">dependencies : 存放线上或者业务能访问的核心代码模块,比如 vue,vue-router;</span><br><span class="line">devDependencies: 处于开发模式下所依赖的开发模块,也许只是用来解析代码,转义代码,但是不产生额外的代码到生产环境, 比如什么babel-core这些</span><br><span class="line"></span><br><span class="line">如何把包安装到对应的依赖下呢?</span><br><span class="line"></span><br><span class="line">npm install --save xxxx        // dependencies</span><br><span class="line">npm install --save-dev xxxx    // devDependencies</span><br><span class="line"></span><br><span class="line">//也能用简易的写法(i:install,-S:save,-D:save-dev)</span><br><span class="line"></span><br><span class="line">npm i -S xxxx   // npm install --save xxxx</span><br><span class="line">npm i -D xxxx   // npm install --save-dev xxxx</span><br></pre></td></tr></table></figure></p><p>Q42: 安装chromedriver报错!!姿势没错啊npm i -D chromedriver<br>恩,伟大的GFW…..解决方案:指定国内的源安装就可以了<br>npm install –save-dev chromedriver –chromedriver_cdnurl=<a href="http://cdn.npm.taobao.org/dist/chromedriver" target="_blank" rel="noopener">http://cdn.npm.taobao.org/dist/chromedriver</a></p><p>Q43:Vue ,React, Angular的比较!<br>Vue属于渐进式开发,传统开发过渡 MVVM 模式的小伙伴,Vue 比较好上手,学习成本比较低基础比较好的,有折腾精神的,可以选择NG5或者React 16;<br>NG5需要学习typescript和rxjs,还用到比较多的新东西,比如装饰器,后端的注入概念.ng有自己的一整套 MVVM 流程;</p><p>而Vue和React核心只是view,可以搭配自己喜欢的</p><p>React的写法偏向函数式写法,还有 jsx,官方自己有 flow,当然也能搭配ts,我也没怎么接触..所以也有一定的学习成本;</p><p>至于哪个比较好!!! 某大神说：“告诉你..若是只会一个框架,那不是一个合格的前端;”<br>人家要的是动手能力,解决能力!!!!技术和待遇是成正比的!!<br><del>颜值和背景,学历,口才可以加分..但是这些条件你必须要有的基础下才能考虑这些!!!</del></p><p>Q44: 有个复杂组件需要有新增和编辑的功能同时存在,但是字段要保持不变性怎么破<br>A：字段保持不变性怎么理解呢? 就是说比如新增和编辑同时共享一份 data;<br>有一种就是路由变了,组件渲染同一个(不引起组件的重新渲染和销毁!),但是功能却不同(新增和编译)..<br>比如从编辑切到新增,data必须为空白没有赋值的,等待我们去赋值;<br>这时候有个东西就特别适合了,那就是immutable-js;<br>这个东西可以模拟数据的唯一性!或者叫做不变性!</p><p>Q45:”首屏加载比较慢!!怎么破!打包文件文件比较大”依次排除和确认:</p><p>减少第三方库的使用,比如jquey这些都可以不要了,很少操作 dom,而且原生基本满足开发<br>若是引入moment这些,webpack 排除国际化语言包<br>webpack 常规压缩js,css, 愿意折腾的还可以引入 dll 这些<br>路由组件采用懒加载<br>加入路由过渡和加载等待效果,虽然不能解决根本,但起码让人等的舒心一点不是么!!!</p><p>整体下来,打包之后一般不会太大;<br>但是倘若想要更快?那就只能采用服务端渲染(SSR)了,可以避免浏览器去解析模板和指令这些;直接返回一个 html ….还能 SEO…</p><p>Q46: Vue SPA 没法做优化(SEO)!有解决方案么</p><p>是的,SSR(服务端渲染就能满足你的需求),因为请求回来就是一个处理完毕的 html</p><p>现在 vue 的服务端开发框架有这么个比较流行,如下</p><p>传送门:<a href="https://zh.nuxtjs.org" target="_blank" rel="noopener">Nuxt.js</a></p><p>Q47: Vue可以写 hybird App 么!</p><p>当然可以,两个方向.</p><ul><li><a href="https://cordova.apache.org/" target="_blank" rel="noopener">codorva</a> + <a href="https://github.com/rigor789/nativescript-vue" target="_blank" rel="noopener">nativescript</a></li><li><a href="https://weex.apache.org/cn/guide/index.html" target="_blank" rel="noopener">Weex</a></li></ul><p>Q48: Vue 可以写桌面端么?</p><p>当然可以,有electron和node-webkit(nw);</p><p>我只了解过electron;</p><p><a href="https://electronjs.org" target="_blank" rel="noopener">electron</a><br><a href="https://github.com/SimulatedGREG/electron-vue" target="_blank" rel="noopener">electron-vue</a>: Vue-cli 针对 electron 的脚手架模板</p><p>Q49: Vue开发,项目中还需要 jQuery么分情况探讨:</p><ul><li>若是老项目,只是单纯引入 Vue 简化开发的,依旧用吧…</li><li>重构项目?或者发起新项目的,其实没必要.开发思路不一样,<strong> 很多以前用 DOM 操作的现在基本可以数据驱动实现 </strong>,而少量迫不得已的DOM 操作原生就能搞定…而且能减小打包体积,速度又快,何乐而不为!!!</li></ul><p>Q50:Vue PC(桌面)端,M(mobile:移动)端,用什么 UI 框架好啊!!!</p><p>PC</p><p>我推荐的只有两个 element UI 和 iview</p><p>Mobile</p><p><a href="http://mint-ui.github.io/docs/#/" target="_blank" rel="noopener">mintui</a><br><a href="https://vux.li/demos/v2/?x-page=v2-doc-home#/" target="_blank" rel="noopener">Vux</a></p><p>当然还有很多,但是基本用户的认知度都不高,这三个比较流行</p><p>Q51: Vue可以写微信小程序么,怎么搞起</p><p>可以的,社区也有人出了对应的解决方案,比如比较流行的方案wepy;<br>wepy你也可以理解为一个脚手架,让你的写小程序的方式更贴近你用vue-cli写 vue 的感觉…</p><p>传送门:<a href="https://wepyjs.github.io/wepy/#/" target="_blank" rel="noopener">wepy</a></p><p>Q52:想要 mock 数据,直接请求 json文件 为什么不行!</p><p>当然不行,浏览器安全机制不允许,JS天生不能越权(NodeJS不能单纯说是JS)</p><p>你要 mock 数据,一般都有比较成熟的方案…传送门:</p><p><a href="https://github.com/nuysoft/Mock" target="_blank" rel="noopener">Mock</a><br><a href="https://github.com/easy-mock/easy-mock" target="_blank" rel="noopener">Easy Mock</a></p><h3 id="Vue-最近的动态"><a href="#Vue-最近的动态" class="headerlink" title="Vue 最近的动态"></a>Vue 最近的动态</h3><p>据说 Vue 3 打算用Proxy拦截器来做数据拦截及响应..这样可以检测到更多数据类型的响应;不过 IE系列全军覆没,polyfill 都不行<br>Vue 目前最新 2.5.3 核心库已适配 typescript 2.6; 但是周边库没跟上(比如第三方的 UI 框架,没有更新对应的 d.ts编译器会报错)..若是组件基本都是自己去写,用 ts+vue开发已经没什么特别的坑了…</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>问题就汇总了这么多…还有一些以前看到了.但是忘记了..想不起来了…后续有看到再补上.</p><p>Github案例<br>学习 jQuery 或者原生 JS<br>jQuery还有很多公司在用,源码可以学习的地方很多;<br>原生 js 是根本,不管是哪个前端框架,最终都是 js 实现的;只有基础扎实,才能学的比较深…<br>框架只是加快开发,提高效率,但不是你在这一行长期立足的根本;<br>前端的人不仅需要宽度,也要深度…这样才能走的更远….</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;trim&quot;&gt;&lt;a href=&quot;#trim&quot; class=&quot;headerlink&quot; title=&quot;.trim&quot;&gt;&lt;/a&gt;.trim&lt;/h3&gt;&lt;p&gt;v-model.trim 去除输入框的空格&lt;/p&gt;
&lt;h3 id=&quot;input绑定数据&quot;&gt;&lt;a href=&quot;#input
      
    
    </summary>
    
    
      <category term="Vuejs" scheme="http://LeilaBlog.site/tags/Vuejs/"/>
    
  </entry>
  
  <entry>
    <title>一些常识</title>
    <link href="http://LeilaBlog.site/2017/11/27/%E4%B8%80%E4%BA%9B%E5%B8%B8%E8%AF%86/"/>
    <id>http://LeilaBlog.site/2017/11/27/一些常识/</id>
    <published>2017-11-27T05:00:16.000Z</published>
    <updated>2018-03-27T09:59:32.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="应该知道的常识"><a href="#应该知道的常识" class="headerlink" title="应该知道的常识"></a>应该知道的常识</h3><h4 id="什么叫优雅降级和渐进增强"><a href="#什么叫优雅降级和渐进增强" class="headerlink" title="什么叫优雅降级和渐进增强"></a>什么叫优雅降级和渐进增强</h4><p>优雅降级（graceful degradation）：一开始就构建站点的完整功能，然后针对浏览器测试和修复。<br>渐进增强（progressive enhancement）：一开始只构建站点的最少特性，然后不断针对各浏览器追加功能。</p><ol><li><p>使用优雅降级方案，Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，绝大多数Web设计师和开发者都通过专门的样式表或针对不同版本的IE的hack实践过优雅降级了；<br>使用优雅降级技术时，你必须首先完整的实现了网站，其中包括所有的功能和效果。然后再为那些无法支持所有功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效。（和当初的兼容IE6）</p></li><li><p>渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能。渐进增强是值得所有开发者采用的做法。渐进增强方案并不假定所有用户都支持javascript，而总是提供一种候补方法，确保用户可以访问（主要的）内容。<br>使用渐进增强时，无需为了一个已成型的网站在旧式浏览器下正常工作而做逆向工程。首先，只需要为所有的设备和浏览器准备好清晰且语义化的HTML以及完善的内容，然后再以无侵入（unobtrusive）的方式向页面增加无害于基础浏览器的额外样式和功能。当浏览器升级时，它们会自动地呈现出来并发挥作用。<br>想让网站在任何环境下看起来都保持一致是不可能的，不管为此付出多少努力，结局依旧会令你失望。与其试图让IE看起来堪比年轻它十岁的浏览器，不如努力改善网站的可访问性，或是进行更多的可用性测试，而不仅仅是让页面看起来更靓一点。<br>某些CSS3特性在不支持它的浏览器中简直是无法模拟实现的，但若使用渐进增强，就无需为了能让你的网站适合所有人而放弃这些技术。仅仅因为部分人不愿或不能升级浏览器，却让使用新型浏览器的用户无法享受CSS3所提供的伟大技术，这是毫无道理可言的。<br>（先把已经都支持的属性都写上，再添加新式浏览器支持的属性，往页面增加无害于基础浏览器[比如最低级的IE系列]的额外样式和功能）</p></li></ol><h4 id="css中link和import的区别"><a href="#css中link和import的区别" class="headerlink" title="css中link和import的区别"></a>css中link和import的区别</h4><p>有 4 种方式可以在 HTML 中引入 CSS。</p><p>1.内联方式</p><p>内联方式指的是直接在 HTML 标签中的 style 属性中添加 CSS。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style=&quot;background: red&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>这通常是个很糟糕的书写方式，它只能改变当前标签的样式，如果想要多个 <div> 拥有相同的样式，你不得不重复地为每个 <div> 添加相同的样式，如果想要修改一种样式，又不得不修改所有的 style 中的代码。很显然，内联方式引入 CSS 代码会导致 HTML 代码变得冗长，且使得网页难以维护。</div></div></p><p>2.嵌入方式</p><p>嵌入方式指的是在 HTML 头部中的”style”标签下书写 CSS 代码。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line"></span><br><span class="line">    .content &#123;</span><br><span class="line">        background: red;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure></p><p>嵌入方式的 CSS 只对当前的网页有效。因为 CSS 代码是在 HTML 文件中，所以会使得代码比较集中，当我们写模板网页时这通常比较有利。因为查看模板代码的人可以一目了然地查看 HTML 结构和 CSS 样式。因为嵌入的 CSS 只对当前页面有效，所以当多个页面需要引入相同的 CSS 代码时，这样写会导致代码冗余，也不利于维护。</p><p>3.链接方式</p><p>链接方式指的是使用 HTML 头部的 <head> 标签引入外部的 CSS 文件。</head></p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;style.css&quot;&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure></p><p>这是最常见的也是最推荐的引入 CSS 的方式。使用这种方式，所有的 CSS 代码只存在于单独的 CSS 文件中，所以具有良好的可维护性。并且所有的 CSS 代码只存在于 CSS 文件中，CSS 文件会在第一次加载时引入，以后切换页面时只需加载 HTML 文件即可。</p><p>4.导入方式</p><p>导入方式指的是使用 CSS 规则引入外部 CSS 文件。</p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    @import url(style.css);</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><p>区别:</p><p>两者都是外部引用CSS的方式，但是存在一定的区别：</p><p>区别1：link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。</p><p>区别2：link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</p><p>区别3：link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</p><p>区别4：link支持使用Javascript控制DOM去改变样式；而@import不支持。</p><h4 id="css浮动的工作原理-清除浮动的技巧"><a href="#css浮动的工作原理-清除浮动的技巧" class="headerlink" title="css浮动的工作原理  清除浮动的技巧"></a>css浮动的工作原理  清除浮动的技巧</h4><p>浮动可以理解为让某个div元素脱离标准流，漂浮在标准流之上，和标准流不是一个层次。</p><p>元素浮动之前，也就是在标准流中，是竖向排列的，而浮动之后可以理解为横向排列。清除浮动可以理解为打破横向排列。</p><p>清除浮动的关键字是clear，官方定义如下：<br>语法：<br>clear : none | left | right | both<br>取值：<br>none : 默认值。允许两边都可以有浮动对象<br>left : 不允许左边有浮动对象<br>right : 不允许右边有浮动对象<br>both : 不允许有浮动对象</p><h4 id="怎么判断一个对象是不是数组类型？"><a href="#怎么判断一个对象是不是数组类型？" class="headerlink" title="怎么判断一个对象是不是数组类型？"></a>怎么判断一个对象是不是数组类型？</h4><p>1、从原型入手，Array.prototype.isPrototypeOf(obj);</p><p>利用isPrototypeOf()方法，判定Array是不是在obj的原型链中，如果是，则返回true,否则false。<br><img src="http://oqt3f60vc.bkt.clouddn.com/type1.png" alt=""></p><p>2、也可以从构造函数入手，obj instanceof Array</p><p>先说说 typeof 和 instanceof 的区别？</p><p>两者都可以用来判断变量，typeof会返回基本类型，如文章开头，我们很简单可以用</p><p>typeof a != ‘undefined’ 判断a变量存在。而instanceof只会返回一个布尔值，那么我们试试，结果如下:<br><img src="http://oqt3f60vc.bkt.clouddn.com/type2.png" alt=""></p><p>上面的方法其实也可以用对象constructor属性，因为在js中每个对象都有constructor属性,这种也常用作判断未知对象的类型。</p><p>例如：typeof arr == “object” &amp;&amp; arr.constructor == Array; //先判断是对象再进一步判断。</p><p>那样是不是这个方法就ok了？别开心那么早，坑总是会有的。</p><p>在一些跨框架的页面中的数组，使用该方法可能不会那么顺利，原因是在不同的框架中创建的数组不会相互共享其prototype属性。</p><p>问题总是要解决的，有没有更加精确的方法呢？==果真有啊！</p><p>3、根据对象的class属性(类属性)，跨原型链调用toString()方法。</p><p>解释一下，在js中一个对象一旦被创建，在内部会携带创建对象的类型名，一旦创建就不能被修改了。那么怎么获取这个对象的类型名呢？</p><p>js中提供了，调用对象原型中的toString方法， Object.prototype.toString.call(obj)；因为很多对象继承的toString（）方法被重写了，为了能够调用正确的toString（）版本，也就是最原始的版本。可以使用Function.call()的方法，其中call可以这么理解，相当于obj去借用这个 Object.prototype.toString();<br><img src="http://oqt3f60vc.bkt.clouddn.com/type3.png" alt=""></p><ol><li>Object.prototype.toString.call(new Date());   //“[object Date]”</li><li>Object.prototype.toString.call(Window);       //“[object window]”</li><li>Object.prototype.toString.call(/./);          //“[object RegExp]”<br>那么有了这个方法，获取对象名可以这样获取：</li></ol><p>或者这么写：<br><img src="http://oqt3f60vc.bkt.clouddn.com/type4.png" alt=""></p><p>function _getClass(o){<br>    if(o===null) return “Null”;<br>    if(o===undfined) return “undefined”;<br>    return Object.prototype.toString.call(o).slice(8,-1);<br>}</p><p>4、Array.isArray()方法。</p><p>其实js已经提供了判断是不是数组类型的方法，如下：<br><img src="http://oqt3f60vc.bkt.clouddn.com/type5.png" alt=""></p><ol><li>Array.isArray([1, 2, 3]);  // true</li><li>Array.isArray({foo: 123}); // false</li><li>Array.isArray(‘foobar’);   // false</li><li>Array.isArray(undefined);  // false　　<br>在MDN中就比较了isArray和instanceof的区别，当Array.isArray()不可用的使用，MDN做了如下的补丁，说明还是比较推荐使用前面讲的第三种方法 Object.prototype.toString.call(obj)。</li></ol><h4 id="简述sessionStorage-localStorage-cookie-的区别？"><a href="#简述sessionStorage-localStorage-cookie-的区别？" class="headerlink" title="简述sessionStorage localStorage cookie 的区别？"></a>简述sessionStorage localStorage cookie 的区别？</h4><p>一.<br>共同点：都是保存在浏览器端，且同源的。<br>区别点：1. cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</p><ol start="2"><li>cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。<br>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。数据有效期不同，</li><li>sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。</li><li>作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。</li><li>Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。</li></ol><p>sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。<br>而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</p><p>二. web storage和cookie的区别</p><p>Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。</p><p>除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。</p><p>但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。</p><p>Cookies:服务器和客户端都可以访问；大小只有4KB左右；有有效期，过期后将会删除；</p><p>本地存储：只有本地浏览器端可访问数据，服务器不能访问本地存储直到故意通过POST或者GET的通道发送到服务器；每个域5MB；没有过期数据，它将保留知道用户从浏览器清除或者使用Javascript代码移除</p><h4 id="简要说明http状态码"><a href="#简要说明http状态码" class="headerlink" title="简要说明http状态码"></a>简要说明http状态码</h4><p>当浏览者访问一个网页时，浏览者的浏览器会向网页所在服务器发出请求。当浏览器接收并显示网页前，此网页所在的服务器会返回一个包含HTTP状态码的信息头（server header）用以响应浏览器的请求。 </p><p>常见的HTTP状态码：<br>200 - 请求成功<br>301 - 资源（网页等）被永久转移到其它URL<br>404 - 请求的资源（网页等）不存在<br>500 - 内部服务器错误</p><p>查看此处 <img src="http://www.runoob.com/http/http-status-codes.html" alt="点击查看"></p><p>HTTP状态码分类<br>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。HTTP状态码共分为5种类型：<br>HTTP状态码分类<br>分类    分类描述<br>1<strong>    信息，服务器收到请求，需要请求者继续执行操作<br>2</strong>    成功，操作被成功接收并处理<br>3<strong>    重定向，需要进一步的操作以完成请求<br>4</strong>    客户端错误，请求包含语法错误或无法完成请求<br>5**    服务器错误，服务器在处理请求的过程中发生了错误</p><p>100-199 用于指定客户端相应的某些动作。<br>200-299 用于表示请求成功。<br>300-399 用于已经移动的文件并且常被包含在定位头信息中指定新的地址信息。<br>400-499 用于指出客户端的错误。<br>500-599 用于支持服务器错误。</p><h4 id="http头部与缓存有关有哪些"><a href="#http头部与缓存有关有哪些" class="headerlink" title="http头部与缓存有关有哪些"></a>http头部与缓存有关有哪些</h4><p>在请求一个静态文件的时候（图片，css，js）等，这些文件的特点是文件不经常变化，将这些不经常变化的文件存储起来，对客户端来说是一个优化用户浏览体验的方法。那么这个就是客户端缓存的意义了。<br>windows下客户端的缓存文件存放在临时文件夹中，但是这里有个问题就是这个缓存文件存放多久呢？这个是由服务端进行设置的。</p><ol><li>Expires/Cache-Control</li></ol><p>HTTP头中的Expires和Cache-Control就是完成这个事情的。</p><p>当客户端第一次访问资源的时候，服务端在返回资源内容的同时也返回了Expires: Sun, 16 Oct 2016 05:43:02 GMT。</p><p>服务端告诉浏览器： 你先把这个文件给我缓存起来，在这个过期时间之前，这个文件都不会变化了，你下次需要这个文件的时候，你就不要过来找我要了，你就去缓存中拿就好了，又快又好。</p><p>浏览器回答说：诺。</p><p>于是在第二次html页面中又要访问这个资源的时候，并且访问的日期在Sun, 16 Oct 2016 05:43:02 GMT之前，浏览器就不去服务器那边获取文件了，自己从缓存中自食其力了。</p><p>但是呢，浏览器毕竟是在客户端的，客户端的时间可是不准确的，用户可以随着自己的喜好修改自己机器的时间，比如我把我机器的时间调成Sun, 16 Oct 2016 05:43:03 GMT，那么呢？我的浏览器就不会再使用缓存了，而每次都去服务器获取文件。于是，服务器怒了：给你个绝对时间，你由于环境被修改没法判断过期，那么我就给你相对时间吧。于是就返回了Cache-Control: max-age:600，浏览器你给我缓存个10分钟去。于是浏览器只有乖乖的缓存10分钟了。</p><p>但是问题又来了，如果有的服务器同时设置了Expires和Cache-Control怎么办呢？（不是闲的没事干，而是由于Cache-Controll是HTTP1.1中才有的）那么就是根据更先进的设置Cache-Control来为标准。</p><p>好了，现在有个问题，我有个文件可能时不时会更新，服务端非常希望客户端能时不时过来问一下这个文件是否过期，如果没有过期，服务端不返回数据给你，只告诉浏览器你的缓存还没有过期（304）。然后浏览器使用自己存储的缓存来做显示。这个就叫做条件请求。</p><ol start="2"><li>Last-Modified/ If-Modify-since</li></ol><p>客户端第一次访问资源的时候，服务端返回资源内容的同时返回了Last-Modifed:Wed, 07 Aug 2013 15:32:18 GMT 服务端在告诉客户端：你获取的这个文件我最后的修改时间是Wed, 07 Aug 2013 15:32:18 GMT 。浏览器在获取这个文件存到缓存中的时候，给缓存中的文件同时记录上这个最后修改时间。</p><p>第二次访问的时候（我们假设这里没有设置expires或者cache-control）。那么服务端访问资源的时候会带上If-Modify-since:Wed, 07 Aug 2013 15:32:18 GMT ；</p><p>客户端询问服务端：喂，我需要的这个资源其实我这边已经有缓存了，我的缓存文件的最后修改时间是这个是，如果你那边的资源在这个时间以后没有修改的话，你就告诉我一下就好了，不需要返回实际的资源内容。反之，要是你有修改的话，你就把文件内容返回给我吧。<br>服务端回应说：哦。行为是看下资源是否在这个时间后没有修改过，如果没有修改返回个304告诉客户端，我没有修改过。如果有变化了，我就返回200，并且带上资源内容。<br>这个条件请求还有另外一种方法，打标签（Tag）</p><ol start="3"><li>ETag/ If-None-Match。<br>第一次客户端访问资源的时候，服务端返回资源内容的同时返回了ETag：1234，告诉客户端：这个文件的标签是1234，我如果修改了我这边的资源的话，这个标签就会不一样了。</li></ol><p>第二次客户端访问资源的时候，由于缓存中已经有了Etag为1234的资源，客户端要去服务端查询的是这个资源有木有过期呢？所以带上了If-None-Match: 1234。告诉服务端：如果你那边的资源还是1234标签的资源，你就返回304告诉我，不需要返回资源内容了。如果不是的话，你再返回资源内容给我就行了。服务端就比较下Etag来看是返回304还是200。</p><ol start="4"><li>各种刷新<br>三种方式<br>浏览器中写地址，回车<br>F5<br>Ctrl+F5</li></ol><p>浏览器url回车<br>浏览器发现缓存中有这个文件了，好了，就不发送任何请求了，直接去缓存中获取展现。（最快）</p><p>F5刷新<br>F5就是告诉浏览器，别偷懒，好歹去服务器看看这个文件是否有过期了。于是浏览器就胆胆襟襟的发送一个请求带上If-Modify-since：Wed, 10 Aug 2013 15:32:18 GMT<br>然后服务器发现：诶，这个文件我在这个时间后还没修改过，不需要给你任何信息了，返回304就行了。于是浏览器获取到304后就去缓存中欢欢喜喜获取资源了。</p><p>Ctrl+F5<br>这个可是要命了，告诉浏览器，你先把你缓存中的这个文件给我删了，然后再去服务器请求个完整的资源文件下来。于是客户端就完成了强行更新的操作…</p><p>ETag实际上很少人使用，因为它的计算是使用算法来得出的，而算法会占用服务端计算的资源，所有服务端的资源都是宝贵的，所以就很少使用etag了。</p><h4 id="模块化编程理解"><a href="#模块化编程理解" class="headerlink" title="模块化编程理解"></a>模块化编程理解</h4><p>什么是模块化？</p><ol><li>模块化就是为了减少系统耦合度，提高高内聚，减少资源循环依赖，增强系统框架设计。</li><li>让开发者便于维护,同时也让逻辑相同的部分可复用</li><li>模块化开发：针对js、css，以功能或业务为单元组织代码。js方面解决独立作用域、依赖管理、</li><li>api暴露、按需加载与执行、安全合并等问题，css方面解决依赖管理、组件内部样式管理等问题。</li><li>任何事物都有一个过程，那么模块化的过程通俗点讲就是：</li></ol><p>模块化的过程就是：</p><p>1、拆分<br>将整个系统按功能,格式,加载顺序,继承关系分割为一个一个单独的部分.<br>注意:拆分的粒度问题,可复用问题,效率问题.如何这些问题处理的不好，就有可能出现不想要的后果。<br>2、归纳<br>将功能或特征相似的部分组合在一起,组成一个资源块.<br>3、总结<br>将每个资源块按找需求,功能场景以及目录约束放到固定的地方以供调用.<br>模块的历程</p><p>模块化的发展也是从草根一步一步走过来的。从最开始到现在成熟方案：</p><p>namespace<br>sass,less<br>AMD&amp;CMD<br>html模版<br>grunt,gulp,webpack<br>FIS,YUI,KISSY</p><h4 id="原生js怎样添加、移除、移动、复制、创建和查找节点，获取元素属性"><a href="#原生js怎样添加、移除、移动、复制、创建和查找节点，获取元素属性" class="headerlink" title="原生js怎样添加、移除、移动、复制、创建和查找节点，获取元素属性"></a>原生js怎样添加、移除、移动、复制、创建和查找节点，获取元素属性</h4><p>（1）创建新节点</p><p>var para=document.createElement(“p”); //创建新的 </p><p> 元素<br>var node=document.createTextNode(“这是新段落。”); //创建了一个文本节点<br>para.appendChild(node); //向 </p><p> 元素追加这个文本节点</p><p>var element=document.getElementById(“div1”);//向一个已有的元素追加这个新元素<br>element.appendChild(para); //向这个已有的元素追加新元素<br>（2）添加、移除、替换、之前插入、之后插入、复制<br>      appendChild()<br>      removeChild()<br>      replaceChild()<br>      insertBefore()<br>      insertAfter()<br>      cloneNode()<br>（3）查找<br>      document.getElementsByTagName(“”)    //通过标签名称<br>      document.getElementsByName(“”)    //通过元素的Name属性的值<br>      document.getElementById(“”)    //通过元素Id，唯一性<br>      document.getElementsByClassName(“”);  //通过类查找<br>      document.querySelector(“”)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;box-one&quot;&gt;</span><br><span class="line">&lt;p id=&quot;p1&quot;&gt;p1p1p1p1&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">//创建节点</span><br><span class="line">var parent=document.createElement(&quot;div&quot;);</span><br><span class="line">var text=document.createTextNode(&quot;这是第一个使用createTexxtNote创建的文本&quot;);</span><br><span class="line">parent.appendChild(text);</span><br><span class="line">//console.log(parent)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//向元素中添加节点</span><br><span class="line">var grandpa=document.querySelector(&quot;.box&quot;);</span><br><span class="line">//console.log(grandpa)</span><br><span class="line">grandpa.appendChild(parent);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//向元素后 添加节点</span><br><span class="line">var p=document.createElement(&apos;p&apos;);</span><br><span class="line">var html=document.createTextNode(&quot;在元素后边添加的代码&quot;);</span><br><span class="line">p.appendChild(html)</span><br><span class="line">insertAfter(p,grandpa);</span><br><span class="line">function insertAfter( newElement, targetElement )&#123; </span><br><span class="line">// newElement是要追加的元素 targetElement 是指定元素的位置 </span><br><span class="line">var grandpa = targetElement.parentNode; // 找到指定元素的父节点 </span><br><span class="line">if( grandpa.lastChild == targetElement )&#123; // 判断指定元素的是否是节点中的最后一个位置 如果是的话就直接使用appendChild方法 </span><br><span class="line">grandpa.appendChild( newElement, targetElement ); </span><br><span class="line">&#125;else&#123; </span><br><span class="line">grandpa.insertBefore( newElement, targetElement.nextSibling ); </span><br><span class="line">&#125;; </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//向元素前 添加节点insertBefore</span><br><span class="line">var h6=document.createElement(&quot;h6&quot;);</span><br><span class="line">var htext=document.createTextNode(&quot;在元素之前添加h6&quot;);</span><br><span class="line">h6.appendChild(htext);</span><br><span class="line">//console.log(htext);</span><br><span class="line">console.log(grandpa)</span><br><span class="line">parent.parentNode.insertBefore(h6,parent);//运用同级的方法在同级元素之前插入</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//元素内部的前面插入节点insertBefore</span><br><span class="line">function inhoutEle() &#123; </span><br><span class="line">var oTest = document.getElementById(&quot;box-one&quot;); </span><br><span class="line">var newNode = document.createElement(&quot;div&quot;); </span><br><span class="line">var reforeNode = document.getElementById(&quot;p1&quot;); </span><br><span class="line">newNode.innerHTML = &quot; 元素内部的前面插入节点 &quot;; </span><br><span class="line">oTest.insertBefore(newNode,reforeNode); // 新建的元素节点插入到 id为p1的元素前面 </span><br><span class="line">&#125; inhoutEle()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//元素内部的后面插入节点appendChild</span><br><span class="line">function inqianEle() &#123; </span><br><span class="line">var oTest = document.getElementById(&quot;box-one&quot;); </span><br><span class="line">var newNode = document.createElement(&quot;div&quot;); </span><br><span class="line">var reforeNode = document.getElementById(&quot;p1&quot;); </span><br><span class="line">newNode.innerHTML = &quot; 元素内部的前面插入节点 &quot;; </span><br><span class="line">oTest.appendChild(newNode,reforeNode); // 新建的元素节点插入到 id为p1的元素前面 </span><br><span class="line">&#125; inqianEle()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>insertBefore() 方法在您指定的已有子节点之前插入新的子节点。<br>语法<br>node.insertBefore(newnode,existingnode)<br>newnode    Node 对象    必需。需要插入的节点对象。<br>existingnode    Node object    可选。在其之前插入新节点的子节点。如果未规定，则 insertBefore 方法会在结尾插入 newnode。</p><h4 id="DOM-事件模型是如何的，编写一个EventUtil工具类实现事件-。。理兼容？？"><a href="#DOM-事件模型是如何的，编写一个EventUtil工具类实现事件-。。理兼容？？" class="headerlink" title="DOM 事件模型是如何的，编写一个EventUtil工具类实现事件 。。理兼容？？"></a>DOM 事件模型是如何的，编写一个EventUtil工具类实现事件 。。理兼容？？</h4><ol><li>DOM<br>首先，DOM全称是Document Object Model，即文档对象模型。DOM是W3C的标准，定义了访问 HTML 和 XML 文档的标准。</li></ol><blockquote><p>“W3C 文档对象模型 （DOM） 是中立于平台和语言的接口，它允许程序和脚本动态地访问和更新文档的内容、结构和样式。”</p></blockquote><ol start="2"><li><p>DOM事件<br>DOM使Javascript有能力对HTML上的事件做出反应。这些事件包括鼠标键盘的点击事件、移动事件以及页面中内容的变化等。HTML元素事件是浏览器内在自动产生的,当有事件发生时html元素会向外界(这里主要指元素事件的订阅者)发出各种事件,如click,onmouseover,onmouseout等等。</p></li><li><p>DOM事件流<br>DOM的结构是一个树形，每当HTML元素产生事件时，该事件就会在树的根节点和元素节点之间传播，所有经过的节点都会收到该事件。</p></li><li><p>DOM事件模型<br>DOM事件模型分为两类：一类是IE所使用的冒泡型事件（Bubbling）；另一类是DOM标准定义的冒泡型与捕获型（Capture）的事件。除IE外的其他浏览器都支持标准的DOM事件处理模型。<br><img src="http://oqt3f60vc.bkt.clouddn.com/DOM1.png" alt="图片示例"></p></li><li><p>冒泡型事件处理模型（Bubbling）<br>如上图所示，冒泡型事件处理模型在事件发生时，首先在最精确的元素上触发，然后向上传播，直到根节点。反映到DOM树上就是事件从叶子节点传播到根节点。</p></li><li><p>捕获型事件处理模型（Captrue）<br>相反地，捕获型在事件发生时首先在最顶级的元素上触发，传播到最低级的元素上。在DOM树上的表现就是由根节点传播到叶子节点。</p></li><li><p>标准的DOM事件处理模型<br> 标准的事件处理模型分为三个阶段：<br> 3-1. 父元素中所有的捕捉型事件（如果有）自上而下地执行<br> 3-2. 目标元素的冒泡型事件（如果有）<br> 3-3. 父元素中所有的冒泡型事件（如果有）自下而上地执行</p></li><li>注册事件监听</li></ol><p>4-1. 传统方式的事件模型即直接在DOM元素上绑定事件处理器，例如—<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.onload=function()&#123;…&#125;</span><br><span class="line">obj.onmouseover=function(e)&#123;…&#125;</span><br><span class="line">obj.onclick=function()&#123;…&#125;</span><br></pre></td></tr></table></figure></p><p>首先这种方式是无论在IE还是Firefox等其他浏览器上都可以成功运行的通用方式。这便是它最大的优势了，而且在Event处理函数内部的this变量无一例外的都只想被绑定的DOM元素，这使得Js程序员可以大大利用this关键字做很多事情。<br>　 至于它的缺点也很明显，就是传统方式只支持Bubbling，而不支持Capturing，并且一次只能绑定一个事件处理器在DOM元素上，无法实现多Handler绑定。最后就是function参数中的event参数只对非IE浏览器有效果( 因为IE浏览器有特制的window.event)。</p><p>4-2. W3C (Firefox.e.g) Event Module<br>Firefox等浏览器很坚决的遵循W3C标准来制定浏览器事件模型，使用addEventListener和removeEventListener两个函数，看几个例子—<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&apos;load&apos;,function()&#123;…&#125;,false);</span><br><span class="line">document.body.addEventListener(&apos;keypress&apos;,function&#123;…&#125;,false);</span><br><span class="line">obj.addEventListener(&apos;mouseover&apos;,MV,true);</span><br><span class="line">function MV()&#123;…&#125;</span><br></pre></td></tr></table></figure></p><p>addEventListener带有三个参数，第一个参数是事件类型，就是我们熟知的那些事件名字去掉前面的’on’，第二个参数是处理函数，可以直接给函数字面量或者函数名，第三个参数是boolean值，表示事件是否支持Capturing。</p><p>W3C的事件模型优点是Bubbling和Capturing都支持，并且可以在一个DOM元素上绑定多个事件处理器，各自并不会冲突。并且在处理函数内部，this关键字仍然可以使用只想被绑定的DOM元素。另外function参数列表的第一个位置(不管是否显示调用)，都永远是event对象的引用。</p><p>至于它的缺点，很不幸的就只有在市场份额最大的IE浏览器下不可使用这一点。</p><p>3、IE Event Module<br>IE自己的事件模型跟W3C的类似，但主要是通过attachEvent和detachEvent两个函数来实现的。依旧看几个例子吧—</p><p>window.attachEvent(‘onload’,function(){…});<br>document.body.attachEvent(‘onkeypress’,myKeyHandler);<br>　　可以发现它跟W3C的区别是没有第三个参数，而且第一个表示事件类型的参数也必须把’on’给加上。这种方式的优点就是能绑定多个事件处理函数在同一个DOM元素上。</p><p>　　至于它的缺点，为什么如今在实际开发中很少见呢？首先IE浏览器本身只支持Bubbling不支持Capturing；而且在事件处理的function内部this关键字也无法使用，因为this永远都只想window object这个全局对象。要想得到event对象必须通过window.event方式，最后一点，在别的浏览器中，它显然是无法工作的。</p><p>4、html中设置锚点定位我知道的有几种方法</p><p>4-1、使用id定位：<br><a href="#1F">去锚点1</a> </p><p><div id="1F">锚点1</div><br>4-2、使用name定位：<br><a href="#5F">锚点5</a><br><a name="5F">1111111<br>4-3、使用js定位 </a></p><li class="" onclick="javascript:document.getElementById('here').scrollIntoView()"></li> ]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;应该知道的常识&quot;&gt;&lt;a href=&quot;#应该知道的常识&quot; class=&quot;headerlink&quot; title=&quot;应该知道的常识&quot;&gt;&lt;/a&gt;应该知道的常识&lt;/h3&gt;&lt;h4 id=&quot;什么叫优雅降级和渐进增强&quot;&gt;&lt;a href=&quot;#什么叫优雅降级和渐进增强&quot; class=&quot;
      
    
    </summary>
    
      <category term="前端" scheme="http://LeilaBlog.site/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="面试经 常识" scheme="http://LeilaBlog.site/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F-%E5%B8%B8%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>js方法</title>
    <link href="http://LeilaBlog.site/2017/11/27/js%E6%96%B9%E6%B3%95/"/>
    <id>http://LeilaBlog.site/2017/11/27/js方法/</id>
    <published>2017-11-27T04:56:08.000Z</published>
    <updated>2018-03-09T09:53:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="splice-该方法会修改数组"><a href="#splice-该方法会修改数组" class="headerlink" title="splice() (该方法会修改数组)"></a>splice() (该方法会修改数组)</h3><p>可使用负值从数组的尾部选取元素</p><ol><li>splice() 方法向/从数组中添加/删除项目，然后返回被删除的项目。<br>注释：该方法会改变原始数组。</li><li>语法<br>arrayObject.splice(index,howmany,item1,…..,itemX)</li><li>参数的描述<br>index: 必需。整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。<br>howmany: 必需。要删除的项目数量。/<em> 如果设置为 0，则不会删除项目。</em>/<br>item1, …, itemX: 可选。向数组所将要添加的新项目。</li><li>返回值<br>Array： 包含被删除项目的新数组，如果有的话。</li><li>说明<br>splice() 方法可删除从 index 处开始的零个或多个元素，并且用参数列表中声明的一个或多个值来替换那些被删除的元素。<br>如果从 arrayObject 中删除了元素，则返回的是含有被删除的元素的数组。</li></ol><p>1-1: 删除项目数为0时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array(6)</span><br><span class="line">arr[0] = &quot;George&quot;</span><br><span class="line">arr[1] = &quot;John&quot;</span><br><span class="line">arr[2] = &quot;Thomas&quot;</span><br><span class="line">arr[3] = &quot;James&quot;</span><br><span class="line">arr[4] = &quot;Adrew&quot;</span><br><span class="line">arr[5] = &quot;Martin&quot;</span><br><span class="line"></span><br><span class="line">document.write(arr + &quot;&lt;br /&gt;&quot;)</span><br><span class="line">arr.splice(2,0,&quot;William&quot;)</span><br><span class="line">document.write(arr + &quot;&lt;br /&gt;&quot;)</span><br></pre></td></tr></table></figure></p><p>systemOut:<br>原先的数组 ：George,John,Thomas,James,Adrew,Martin<br>splice()后：George,John,William,Thomas,James,Adrew,Martin</p><p>1-2: 我将删除位于 index 2 的元素，并添加一个新元素来替代被删除的元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array(6)</span><br><span class="line">arr[0] = &quot;George&quot;</span><br><span class="line">arr[1] = &quot;John&quot;</span><br><span class="line">arr[2] = &quot;Thomas&quot;</span><br><span class="line">arr[3] = &quot;James&quot;</span><br><span class="line">arr[4] = &quot;Adrew&quot;</span><br><span class="line">arr[5] = &quot;Martin&quot;</span><br><span class="line"></span><br><span class="line">document.write(arr + &quot;&lt;br /&gt;&quot;)</span><br><span class="line">arr.splice(2,1,&quot;William&quot;)</span><br><span class="line">document.write(arr)</span><br></pre></td></tr></table></figure></p><p>输出：<br>原先的数组 ：George,John,Thomas,James,Adrew,Martin<br>splice()后：George,John,William,James,Adrew,Martin</p><p>1-3：我们将删除从 index 2 (“Thomas”) 开始的三个元素，并添加一个新元素 (“William”) 来替代被删除的元素：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array(6)</span><br><span class="line">arr[0] = &quot;George&quot;</span><br><span class="line">arr[1] = &quot;John&quot;</span><br><span class="line">arr[2] = &quot;Thomas&quot;</span><br><span class="line">arr[3] = &quot;James&quot;</span><br><span class="line">arr[4] = &quot;Adrew&quot;</span><br><span class="line">arr[5] = &quot;Martin&quot;</span><br><span class="line"></span><br><span class="line">document.write(arr + &quot;&lt;br /&gt;&quot;)</span><br><span class="line">arr.splice(2,3,&quot;William&quot;)</span><br><span class="line">document.write(arr)</span><br></pre></td></tr></table></figure></p><p>输出：<br>原先的数组 ：George,John,Thomas,James,Adrew,Martin<br>splice()后：George,John,William,Martin</p><h3 id="slice-方法可从已有的数组中返回选定的元素。-该方法并不会修改数组"><a href="#slice-方法可从已有的数组中返回选定的元素。-该方法并不会修改数组" class="headerlink" title="slice() 方法可从已有的数组中返回选定的元素。 (该方法并不会修改数组)"></a>slice() 方法可从已有的数组中返回选定的元素。 (该方法并不会修改数组)</h3><p>start 到 end （不包括end所对应元素）<br>可使用负值从数组的尾部选取元素</p><ol><li>语法<br>arrayObject.slice(start,end)</li><li>参数的描述<br>start: 必需。规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，/<em> -1 指最后一个元素，-2 指倒数第二个元素 </em>/，以此类推。<br>end    可选。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start /<em> 到数组结束 </em>/的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。</li><li>我们将创建一个新数组，然后显示从其中选取的元素：不写end的话，默认从start截取到数组结尾<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array(3)</span><br><span class="line">arr[0] = &quot;George&quot;</span><br><span class="line">arr[1] = &quot;John&quot;</span><br><span class="line">arr[2] = &quot;Thomas&quot;</span><br><span class="line"></span><br><span class="line">document.write(arr + &quot;&lt;br /&gt;&quot;)</span><br><span class="line">document.write(arr.slice(1) + &quot;&lt;br /&gt;&quot;)</span><br><span class="line">document.write(arr)</span><br></pre></td></tr></table></figure></li></ol><p>输出：<br>George,John,Thomas<br>John,Thomas<br>George,John,Thomas</p><ol start="2"><li>start 和 end都写(start 到 end （不包括end对应元素）)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr = new Array(6)</span><br><span class="line">arr[0] = &quot;George&quot;</span><br><span class="line">arr[1] = &quot;John&quot;</span><br><span class="line">arr[2] = &quot;Thomas&quot;</span><br><span class="line">arr[3] = &quot;James&quot;</span><br><span class="line">arr[4] = &quot;Adrew&quot;</span><br><span class="line">arr[5] = &quot;Martin&quot;</span><br><span class="line"></span><br><span class="line">document.write(arr + &quot;&lt;br /&gt;&quot;)</span><br><span class="line">document.write(arr.slice(2,4) + &quot;&lt;br /&gt;&quot;)</span><br><span class="line">document.write(arr)</span><br></pre></td></tr></table></figure></li></ol><p>George,John,Thomas,James,Adrew,Martin<br>/<em> Thomas,James </em>/<br>George,John,Thomas,James,Adrew,Martin</p><p>toggle用法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(function()&#123;</span><br><span class="line">    $(&quot;.box&quot;).toggle(function()&#123;</span><br><span class="line">        $(this).css(&quot;background&quot;,&quot;red&quot;)</span><br><span class="line">    &#125;,function()&#123;</span><br><span class="line">        $(this).css(&quot;background&quot;,&quot;blue&quot;) </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;splice-该方法会修改数组&quot;&gt;&lt;a href=&quot;#splice-该方法会修改数组&quot; class=&quot;headerlink&quot; title=&quot;splice() (该方法会修改数组)&quot;&gt;&lt;/a&gt;splice() (该方法会修改数组)&lt;/h3&gt;&lt;p&gt;可使用负值从数组的尾
      
    
    </summary>
    
      <category term="js 原生js事件" scheme="http://LeilaBlog.site/categories/js-%E5%8E%9F%E7%94%9Fjs%E4%BA%8B%E4%BB%B6/"/>
    
    
      <category term="javascript  原生js事件" scheme="http://LeilaBlog.site/tags/javascript-%E5%8E%9F%E7%94%9Fjs%E4%BA%8B%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>css</title>
    <link href="http://LeilaBlog.site/2017/11/27/css/"/>
    <id>http://LeilaBlog.site/2017/11/27/css/</id>
    <published>2017-11-27T04:50:41.000Z</published>
    <updated>2018-02-27T04:02:40.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="日常实用css布局技巧汇总"><a href="#日常实用css布局技巧汇总" class="headerlink" title="日常实用css布局技巧汇总"></a>日常实用css布局技巧汇总</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> 1.单行完整显示，多行省略显示。</span><br><span class="line"></span><br><span class="line">　　.box &#123;</span><br><span class="line">　　　　width: 100px;　　　　 //必要</span><br><span class="line">　　　　display: -webkit-box;    //必要</span><br><span class="line">　　　　font-size: 14px;</span><br><span class="line">　　　　line-height: 20px;</span><br><span class="line">　　　　text-overflow: ellipsis;  //必要</span><br><span class="line">　　　　-webkit-line-clamp: 2;  //必要</span><br><span class="line">　　　　-webkit-box-orient: vertical;  //必要</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">2.对高度不定的容器设置背景(可能滚动)　</span><br><span class="line"></span><br><span class="line">　　.container &#123;</span><br><span class="line"></span><br><span class="line">　　　　width: 100%;</span><br><span class="line"></span><br><span class="line">　　　　position: relative;    //absolute也能达到效果，视具体情况而定</span><br><span class="line"></span><br><span class="line">　　　　top: 0;</span><br><span class="line"></span><br><span class="line">　　　　bottom: 0;</span><br><span class="line"></span><br><span class="line">　　　　min-height: 100%;</span><br><span class="line"></span><br><span class="line">　　　　background-color: #f1f1f1;</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">3.单行完整显示，多行正常换行</span><br><span class="line"></span><br><span class="line">　　.box&#123;</span><br><span class="line"></span><br><span class="line">　　　　width: 100px;       //必要</span><br><span class="line"></span><br><span class="line">　　　　word-warp: break-word;   //必要</span><br><span class="line"></span><br><span class="line">　　　　word-break: break-all;      //必要</span><br><span class="line"></span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure><h3 id="background-size背景图片尺寸属性"><a href="#background-size背景图片尺寸属性" class="headerlink" title="background-size背景图片尺寸属性"></a>background-size背景图片尺寸属性</h3><ul><li>background-size 可以设置背景图片的大小，数值包括 长度length和百分比percentage。 并且会根据背景原点位置 background-origin 设置其图片覆盖的范围。background-size属性：</li></ul><p>属性名:    background-size</p><p><strong> 属性值:     <code>&lt;bg-size&gt;</code>其中 bg-size = [ <length> | <percentage> | auto ]{1,2} | cover | contain </percentage></length></strong></p><p>初始值:    auto auto</p><p>应用于:    所有元素</p><p>继承性:    无</p><p>百分比:    见下文注解</p><p>计算值:    根据指定</p><ul><li>语法解释</li></ul><ol><li>length，percentage，根据给定长度值或者百分比来调整背景图片大小。auto为默认值，这三个值最小可重复一次，最大重复两次。对于这些值有以下解释：<br>第一个值为设置图片宽度，第二个值为图片的高度；但是不管是用什么值，都不能为负值<br>假如只给定一个值，那么第二个自动的为 ‘auto’；<br>假如指定为 percentage百分比值，那么背景图大小是根据相对的背景区域来做调整，这个背景区域是由background-origin来来决定的。这在上面已经有提到过了关于图片原点的讨论。这里有必要提到 假如background-attachment:fixed，那么其背景相对区域就是初始包含块也就是视窗<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">**  一个值: 这个值指定图片的宽度，那么第二个值为auto  **</span><br><span class="line">background-size: auto</span><br><span class="line">background-size: 50%</span><br><span class="line">background-size: 3em</span><br><span class="line">background-size: 12px</span><br><span class="line"></span><br><span class="line">** 两个值: 第一个值指定图片的宽度，第二个值指定图片的高度 **</span><br><span class="line">background-size: 50% auto</span><br><span class="line">background-size: 3em 25%</span><br><span class="line">background-size: auto 6px</span><br><span class="line">background-size: auto auto</span><br><span class="line">** 多重背景，请用逗号隔开，在CSS语法中凡语法后跟*或者#，都是可以无限重复的，但是必须用逗号隔开。 **</span><br><span class="line">background-size: auto, auto     /* 不要跟background-size: auto auto混淆了 */</span><br><span class="line">background-size: 50%, 25%, 25%</span><br><span class="line">background-size: 6px, auto, contain</span><br><span class="line"></span><br><span class="line">background-size: inherit</span><br></pre></td></tr></table></figure></li></ol><p>2.contain，按比例调整背景图片，使得其图片宽高比自适应整个元素的背景区域的宽高比，因此假如指定的图片尺寸过大，而背景区域的整体宽高不能恰好包含背景图片的话，那么其背景某些区域可能会有空白。看以下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.im-com&#123;</span><br><span class="line">    width:200px;</span><br><span class="line">    height:50px;    </span><br><span class="line">    background:url(http://img.xiaoho.com/mystar/mada4.jpg) no-repeat top left scroll;   /*图片的宽高为440*440，而元素相对区域高度为50*/ </span><br><span class="line">    background-size:contain;</span><br><span class="line">&#125;</span><br><span class="line">.im-com-1&#123;</span><br><span class="line">    width:50px;</span><br><span class="line">    height:100px;   </span><br><span class="line">    background:url(http://img.xiaoho.com/mystar/mada4.jpg) no-repeat top left scroll;   /*元素相对区域宽度为50*/ </span><br><span class="line">    background-size:contain;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>/<em> CSS3background-size背景图片尺寸属性 当图片恰好自适应铺满元素的宽度或者高度，那么元素的会有空白处存在，也就是图中红色框框都显示了空白。</em>/</p><p>3.cover，按比例调整背景图片，这个属性值跟contain正好相反，背景图片会按照比如自适应铺满整个背景区域。假如背景区域不足以包含背景图片的话，那么背景图片就会被咔嚓。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.im-com&#123;</span><br><span class="line">    width:200px;</span><br><span class="line">    height:50px;    </span><br><span class="line">    background:url(http://img.xiaoho.com/mystar/mada4.jpg) no-repeat top left scroll;   /*图片的宽高为440*440，而元素相对区域高度为50*/ </span><br><span class="line">    background-size:cover;</span><br><span class="line">&#125;</span><br><span class="line">.im-com-1&#123;</span><br><span class="line">    width:50px;</span><br><span class="line">    height:100px;   </span><br><span class="line">    background:url(http://img.xiaoho.com/mystar/mada4.jpg) no-repeat top left scroll;   /*元素相对区域宽度为50*/ </span><br><span class="line">    background-size:cover;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>/<em> CSS3background-size背景图片尺寸属性 当使用了 cover 这个值的时候，那么正好就跟contain相反，其会正好覆盖整个背景相对区域，但是背景图片的某些部分就看不见，如下图的狗的下半身和右侧身体显示不全。</em>/</p><p>/<em> 说说背景图片计算值 </em>/<br>假如说只是拿单一的数值或者具体数值来解释那理解起来应该不难，但假如用混合长度来说，可能会有点一下子明白不上来<br>先声明：所有的元素的尺寸为100*100</p><p>100% 100%背景图片将铺满整个内容区，假如说元素有固有宽高，那么背景图片铺满整个100*100背景区域</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">    background-image: url(plasma.png);</span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line">    background-size: 100% 100%;</span><br><span class="line">    background-origin: content-box &#125;</span><br><span class="line">背景图片调整为宽度为50*50，但是背景图片的原点位置为边框box而不是padding-box</span><br><span class="line">p &#123;</span><br><span class="line">    background-image: url(tubes.png);</span><br><span class="line">    background-size: 50% auto;</span><br><span class="line">    background-origin: border-box &#125;</span><br><span class="line">背景图片尺寸调整为15*15</span><br><span class="line">para &#123;</span><br><span class="line">    background-size: 15px 15px;</span><br><span class="line">    background-image: url(tile.png)&#125;</span><br><span class="line">这是默认值，也就是auto auto，此时背景图片的尺寸将会是跟图片的固有尺寸一样.</span><br><span class="line"></span><br><span class="line">body &#123;</span><br><span class="line">    background-size: auto;            /* 默认值 */</span><br><span class="line">    background-image: url(flower.png) &#125;</span><br><span class="line">假如两个都是百分比，此时图片就会根据背景区域来按照宽高比自适应，此处背景图片为20*30，但是因为背景重复用了 &apos;round&apos;循环，因此背景区域高度划分了3个33.3等高区域，所以背景图片会自适应调整为20*33.3</span><br><span class="line">p &#123;</span><br><span class="line">    background-image: url(chain.png);</span><br><span class="line">    background-repeat: no-repeat round;</span><br><span class="line">    background-size: 20% 30% </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>border-radius用于设置HTML元素的圆角效果，但只有IE9、chorme及firefox浏览器支持该属性，IE8及以下浏览器不兼容也不支持border-radius属性</p><p>letter-spacing  设置对象中的文字(汉字和字母)之间的间隔。 效果eg：这 里 是 C S S W e b<br>word-spacing    设置对象中的英文单词之间的间隔。         效果eg：css web design</p><p>水平<br>background-repeat:repeat-x; 不写的话默认也是向x轴平铺<br>background-position: x y<br>                    bottom left(也可识别 最好不要这样)<br>                    left  center right<br>                    top   center bottom<br>                    center 0px  (将完整的一张图片放到背景的中间  左右该留多少多少)<br>background-attachment:fixed (背景固定)</p><p>也可以复合样式<br>background：gray url() no-repeat 100px 0px scroll/fixed ;</p><p>border:1px solid red;<br>border:1px dashed red;  虚线<br>border:1px dotted red;  点化线有兼容问题  有时圆点  有时方点</p><p>多余的文字…显示<br> /<em><br>    1、得是以配置为inline-block的元素，或默认以block呈现的div、p元素<br>    2、强制不换行<br>    3、固定宽度<br>    4、超出部分隐藏<br>    5、超出部分以’…’结尾  </em>/<br>    display: inline-block;<br>    white-space: nowrap;<br>    width: 140px;<br>    overflow: hidden;<br>    text-overflow:ellipsis;  </p><h3 id="user-select-none"><a href="#user-select-none" class="headerlink" title="user-select:none"></a>user-select:none</h3><p>user-select：none | text | all | element<br>默认值：text<br>适用于：除替换元素外的所有元素<br>继承性：无<br>动画性：否<br>计算值：指定值</p><ol><li>取值：<br>none：<br>文本不能被选择<br>text：<br>可以选择文本<br>all：<br>当所有内容作为一个整体时可以被选择。如果双击或者在上下文上点击子元素，那么被选择的部分将是以该子元素向上回溯的最高祖先元素。<br>element：<br>可以选择文本，但选择范围受元素边界的约束</li><li>说明：<br>设置或检索是否允许用户选中文本。</li><li>浏览器的支持性<br>IE6-9不支持该属性，但支持使用标签属性 onselectstart=”return false;” 来达到 user-select:none 的效果；Safari和Chrome也支持该标签属性；<br>直到Opera12.5仍然不支持该属性，但和IE6-9一样，也支持使用私有的标签属性 unselectable=”on” 来达到 user-select:none 的效果；unselectable 的另一个值是 off；<br>除Chrome和Safari外，在其它浏览器中，如果将文本设置为 -ms-user-select:none;，则用户将无法在该文本块中开始选择文本。不过，如果用户在页面的其他区域开始选择文本，则用户仍然可以继续选择将文本设置为 -ms-user-select:none; 的区域文本；<br>对应的脚本特性为userSelect。<h3 id="resize属性"><a href="#resize属性" class="headerlink" title="resize属性"></a>resize属性</h3>resize 属性规定是否可由用户调整元素的尺寸。<br>注释：如果希望此属性生效，需要设置元素的 overflow 属性，值可以是 auto、hidden 或 scroll。</li><li>语法<br>resize: none|both|horizontal|vertical;</li><li>值于描述<br>none——用户无法调整元素的尺寸。<br>both——用户可调整元素的高度和宽度。<br>horizontal——用户可调整元素的宽度。<br>vertical——用户可调整元素的高度。</li></ol><h3 id="webkit-touch-callout"><a href="#webkit-touch-callout" class="headerlink" title="-webkit-touch-callout"></a>-webkit-touch-callout</h3><p>-webkit-touch-callout 是一个 不规范的属性（unsupported WebKit property），它没有出现在 CSS 规范草案中。<br>/<em> 当你触摸并按住触摸目标时候，禁止或显示系统默认菜单。</em>/ 在iOS上，当你触摸并按住触摸的目标，比如一个链接，Safari浏览器将显示链接有关的系统默认菜单。这个属性可以让你禁用系统默认菜单。</p><p>2017/12/4</p><h3 id="暖人心却鲜为人知的CSS属性"><a href="#暖人心却鲜为人知的CSS属性" class="headerlink" title="暖人心却鲜为人知的CSS属性"></a>暖人心却鲜为人知的CSS属性</h3><ol><li>attr<br>CSS表达式 attr() 用来获取选择到的元素的某一HTML属性值，并用于其样式。它也可以用于伪元素，属性值采用伪元素所依附的元素。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;p data-unit=&quot;℃&quot;&gt;当前温度36&lt;/P&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">[data-unit]:after&#123;</span><br><span class="line">    content:attr(data-unit);</span><br><span class="line">    color:red;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ol><p><img src="http://oqt3f60vc.bkt.clouddn.com/css%E6%9C%AA%E7%9F%A5%E5%B1%9E%E6%80%A7.webp" alt="css Attr属性"><br>IE只有IE11才支持，其他浏览器可以安全使用</p><h3 id="currentColor"><a href="#currentColor" class="headerlink" title="currentColor"></a>currentColor</h3><p>currentColor不是一个css属性，而是color的属性值。它返回当前的标签所继承的文字颜色。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;outside&quot;&gt;</span><br><span class="line">   &lt;div class=&quot;inside&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;style&gt;</span><br><span class="line">.outside&#123;</span><br><span class="line">    width:200px;</span><br><span class="line">    height:200px;</span><br><span class="line">    color:blue;</span><br><span class="line">    backgroud-color:yellow;</span><br><span class="line">&#125;</span><br><span class="line">.inside&#123;</span><br><span class="line">    width:100px;</span><br><span class="line">    height:100px;</span><br><span class="line">    color:red;</span><br><span class="line">    background-color:pink;</span><br><span class="line">    border:1px solid currentColor;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></p><p><img src="http://oqt3f60vc.bkt.clouddn.com/css%E7%9A%84currentColor.webp" alt="currentColor属性"><br>可以看出，最终.inside的border颜色为red，即当前元素的color值。<br>IE只有IE11才支持，其他浏览器可以安全使用</p><h3 id="user-select"><a href="#user-select" class="headerlink" title="user-select"></a>user-select</h3><p>控制选取能否被选择. (可以禁止用户选中内容)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.disable-select&#123;</span><br><span class="line">    -webkit-user-select:none;</span><br><span class="line">    -moz-user-select:none;</span><br><span class="line">    user-select:none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>浏览器兼容：</p><p><img src="http://oqt3f60vc.bkt.clouddn.com/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9.webp" alt=""></p><h3 id="selection"><a href="#selection" class="headerlink" title="selection"></a>selection</h3><p>::selection CSS伪元素应用于文档中被用户高亮的部分（比如使用鼠标或其他选择设备选中的部分）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;选中这行文字&lt;/p&gt;</span><br><span class="line">&lt;!-- 选中文字渲染成黑色背景白色前景 --&gt;</span><br><span class="line">p::-moz-selection&#123;</span><br><span class="line">    color:white;</span><br><span class="line">    background:block;</span><br><span class="line">&#125;</span><br><span class="line">p::selection&#123;</span><br><span class="line">    color:white;</span><br><span class="line">    background:black;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="http://oqt3f60vc.bkt.clouddn.com/css%E7%9A%84selection.webp" alt=""></p><p>浏览器兼容性：</p><p><img src="http://oqt3f60vc.bkt.clouddn.com/%E5%85%BC%E5%AE%B9%E6%80%A72.webp" alt=""></p><h3 id="will-change"><a href="#will-change" class="headerlink" title="will-change"></a>will-change</h3><p>CSS 属性 will-change 为web开发者提供了一种告知浏览器该元素会有哪些变化的方法，这样浏览器可以在元素属性真正发生变化之前提前做好对应的优化准备工作。 这种优化可以将一部分复杂的计算工作提前准备好，使页面的反应更为快速灵敏。</p><p>这个属性作用很单纯，就是“增强页面渲染性能”。那它是如何增强的呢？</p><p>当我们通过某些行为（点击、移动或滚动）触发页面进行大面积绘制的时候，浏览器往往是没有准备的，只能被动使用CPU去计算与重绘，由于没有事先准备，应付渲染够呛，于是掉帧，于是卡顿。而will-change则是真正的行为触发之前告诉浏览器：“浏览器同学，我待会儿就要变形了，你心理和生理上都准备准备”。于是乎，浏览器同学把GPU给拉上了，从容应对即将到来的变形。</p><p>这其实很好理解的，对吧，提前预约从容不迫；突然造访手忙脚乱。</p><p>MDN上显示该属性语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/* 关键字值 */</span><br><span class="line">will-change: auto;</span><br><span class="line">will-change: scroll-position;</span><br><span class="line">will-change: contents;</span><br><span class="line">will-change: transform;        /* &lt;custom-ident&gt;示例 */</span><br><span class="line">will-change: opacity;          /* &lt;custom-ident&gt;示例 */</span><br><span class="line">will-change: left, top;        /* 两个&lt;animateable-feature&gt;示例 */</span><br><span class="line"></span><br><span class="line">/* 全局值 */</span><br><span class="line">will-change: inherit;</span><br><span class="line">will-change: initial;</span><br><span class="line">will-change: unset;</span><br></pre></td></tr></table></figure></p><p>其中：<br>auto就跟width:auto一样，实际上没什么卵用，昨天嘛，估计就是用来重置其他比较屌的值。</p><p>scroll-position告诉浏览器，我要开始翻滚了。</p><p>contents告诉浏览器，内容要动画或变化了。</p><p><code>&lt;custom-ident&gt;</code>顾名思意，自定义的识别。非规范称呼，应该是MDN自己的称呼，以后可能会明确写入规范。比方说animation的名称，计数器counter-reset, counter-increment定义的名称等等。</p><p>上面展示了2个例子，一个是transform一个是opacity，都是CSS3动画常用属性。如果给定的属性是缩写，则所有缩写相关属性变化都会触发。同时不能是以下这些关键字值：unset, initial, inherit, will-change, auto, scroll-position, 或 contents.</p><p><code>&lt;animateable-feature&gt;</code>可动画的一些特征值。比方说left, top, margin之类。移动端，非transform, opacity属性的动画性能都是低下的，所以都是建议避免使用left/top/margin之流进行唯一等。但是，如果你觉得自己是margin属性奶大的，非要使用之，试试加个will-change:margin说不定也会很流畅（移动端目前支持还不是很好）。</p><p>就目前而言，使用的基本上都是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.example &#123;</span><br><span class="line">  will-change: transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>will-change虽然可以加速，但是，一定一定要适度使用。那种全局都开启will-change等待模式的做法，无疑是死路一条。尼玛，用脚趾头想想也知道，你让浏览器各个元素都随时GPU渲染加速待命，还是妥妥搞死！</p><p>说到这里，想到了移动端的GPU加速。很多自以为然的同学写CSS3动画的时候，或者静态属性的时候，动不动就把translateZ之类GPU hack属性写上。同学们啊，GPU这玩意提高页面渲染性能它是有代价的呀，什么代价呢，就是手机的电量。你真以为有“既要马儿跑，又要马儿不吃草”的好事情啊！</p><p>平时，我们一般地CSS动画，平常的渲染处理，手机都是可以比较流畅的。完全没有必要以牺牲其他东西来实现。手机上的电量弥足珍贵。如果发现(尤其Android)机子h5页面不流畅，找找看是不是动画属性使用问题，或者非可视动画层没隐藏等等原因。</p><p>回到will-change. 同样的，will-change的使用也要谨慎，遵循最小化影响原则，所以，一开始的例子，才使用伪元素去搞，独立渲染（虽然我没看出来这个梗在什么地方）。</p><p>不要这样直接写在默认状态中，因为will-change会一直挂着：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.will-change &#123;</span><br><span class="line">  will-change: transform;</span><br><span class="line">  transition: transform 0.3s;</span><br><span class="line">&#125;</span><br><span class="line">.will-change:hover &#123;</span><br><span class="line">  transform: scale(1.5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以让父元素hover的时候，声明will-change，这样，移出的时候就会自动remove，触发的范围基本上是有效元素范围。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.will-change-parent:hover .will-change &#123;</span><br><span class="line">  will-change: transform;</span><br><span class="line">&#125;</span><br><span class="line">.will-change &#123;</span><br><span class="line">  transition: transform 0.3s;</span><br><span class="line">&#125;</span><br><span class="line">.will-change:hover &#123;</span><br><span class="line">  transform: scale(1.5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果使用JS添加will-change, 事件或动画完毕，一定要及时remove. 比方说点击某个按钮，其他某个元素进行动画。点击按钮(click)，要先按下(mousedown)再抬起才出发。因此，可以mousedown时候打声招呼, 动画结束自带回调，于是（示意，不要在意细节）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dom.onmousedown = function() &#123;</span><br><span class="line">    target.style.willChange = &apos;transform&apos;;</span><br><span class="line">&#125;;</span><br><span class="line">dom.onclick = function() &#123;</span><br><span class="line">    // target动画哔哩哔哩...</span><br><span class="line">&#125;;</span><br><span class="line">target.onanimationend = function() &#123;</span><br><span class="line">    // 动画结束回调，移除will-change</span><br><span class="line">    this.style.willChange = &apos;auto&apos;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>等。</p><p><a href="http://www.zhangxinxu.com/wordpress/2015/11/css3-will-change-improve-paint/" target="_blank" rel="noopener">《使用CSS3 will-change提高页面滚动、动画等渲染性能》</a></p><p>浏览器兼容性</p><p><img src="http://oqt3f60vc.bkt.clouddn.com/%E5%85%BC%E5%AE%B9%E6%80%A73.webp" alt=""></p><p><a href="http://www.css88.com/book/css/" target="_blank" rel="noopener">css手册全集详解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;日常实用css布局技巧汇总&quot;&gt;&lt;a href=&quot;#日常实用css布局技巧汇总&quot; class=&quot;headerlink&quot; title=&quot;日常实用css布局技巧汇总&quot;&gt;&lt;/a&gt;日常实用css布局技巧汇总&lt;/h3&gt;&lt;figure class=&quot;highlight plai
      
    
    </summary>
    
      <category term="css属性杂点" scheme="http://LeilaBlog.site/categories/css%E5%B1%9E%E6%80%A7%E6%9D%82%E7%82%B9/"/>
    
    
      <category term="css" scheme="http://LeilaBlog.site/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>mouse事件</title>
    <link href="http://LeilaBlog.site/2017/11/27/mouse%E4%BA%8B%E4%BB%B6/"/>
    <id>http://LeilaBlog.site/2017/11/27/mouse事件/</id>
    <published>2017-11-27T03:58:48.000Z</published>
    <updated>2017-11-27T03:59:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="DOM3-级事件中定义了9个鼠标事件"><a href="#DOM3-级事件中定义了9个鼠标事件" class="headerlink" title="DOM3 级事件中定义了9个鼠标事件"></a>DOM3 级事件中定义了9个鼠标事件</h3><ol><li>click：在用户单击主鼠标按钮（一般是左边的按钮）</li><li>dblclick：在用户双击主鼠标按钮（一般是左边的按钮）时触发</li><li>mousedown：在用户按下了任意鼠标按钮时触发。不能通过键盘触发这个事件</li><li>mouseenter：在鼠标光标从元素外部首次移动到元素范围之内时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。DOM2级事件并没有定义这个事件，但 DOM3级事件将它纳入了规范。IE、Firefox 9+和 Opera支持这个事件。</li><li>mouseleave：在位于元素上方的鼠标光标移动到元素范围之外时触发。这个事件不冒泡，而且在光标移动到后代元素上不会触发。DOM2级事件并没有定义这个事件，但 DOM3级事件将它 纳入了规范。IE、Firefox 9+和 Opera支持这个事件。</li><li>mousemove：当鼠标指针在元素内部移动时重复地触发。不能通过键盘触发这个事件。</li><li>mouseout：在鼠标指针位于一个元素上方，然后用户将其移入另一个元素时触发。又移入的另一个元素可能位于前一个元素的外部，也可能是这个元素的子元素。不能通过键盘触发这个事件。</li><li>mouseover：在鼠标指针位于一个元素外部，然后用户将其首次移入另一个元素边界之内时触 发。不能通过键盘触发这个事件。</li><li>mouseup：在用户释放鼠标按钮时触发。不能通过键盘触发这个事件。</li></ol><p>结语：<br>页面上的所有元素都支持鼠标事件。除了 mouseenter 和 mouseleave，所有鼠标事件都会冒泡， 也可以被取消，而取消鼠标事件将会影响浏览器的默认行为。取消鼠标事件的默认行为还会影响其他事 件，因为鼠标事件与其他事件是密不可分的关系。</p><h3 id="理解-e-clientX-e-clientY-e-pageX-e-pageY-e-offsetX-e-offsetY"><a href="#理解-e-clientX-e-clientY-e-pageX-e-pageY-e-offsetX-e-offsetY" class="headerlink" title="理解 e.clientX,e.clientY e.pageX e.pageY e.offsetX e.offsetY"></a>理解 e.clientX,e.clientY e.pageX e.pageY e.offsetX e.offsetY</h3><ol><li>event.clientX、event.clientY</li></ol><p>鼠标相对于浏览器窗口可视区域的X，Y坐标（窗口坐标），可视区域不包括工具栏和滚动条。IE事件和标准事件都定义了这2个属性</p><ol start="2"><li>event.pageX、event.pageY</li></ol><p>类似于event.clientX、event.clientY，但它们使用的是文档坐标而非窗口坐标。这2个属性不是标准属性，但得到了广泛支持。IE事件中没有这2个属性。</p><ol start="3"><li>event.offsetX、event.offsetY</li></ol><p>鼠标相对于事件源元素（srcElement）的X,Y坐标，只有IE事件有这2个属性，标准事件没有对应的属性。</p><ol start="4"><li>event.screenX、event.screenY</li></ol><p>鼠标相对于用户显示器屏幕左上角的X,Y坐标。标准事件和IE事件都定义了这2个属性</p><p><img src="http://oqt3f60vc.bkt.clouddn.com/eventY.png" alt="图示解析"></p><h3 id="JSON-parse-和JSON-stringify"><a href="#JSON-parse-和JSON-stringify" class="headerlink" title="JSON.parse()和JSON.stringify()"></a>JSON.parse()和JSON.stringify()</h3><p>前者字符串转化成数组;后者将数组转化成字符串</p><ol><li>parse 用于从一个字符串中解析出json 对象。例如</li></ol><p>var str=’{“name”:”cpf”,”age”:”23”}’</p><p>经 JSON.parse(str) 得到：</p><p>Object: age:”23”<br>        name:”cpf”<br>        <em>proto</em>:Object</p><p>ps:单引号写在{}外，每个属性都必须双引号，否则会抛出异常</p><ol start="2"><li>stringify用于从一个json对象解析出字符串，例如</li></ol><p>var a={a:1,b:2}</p><p>经 JSON.stringify(a)得到：</p><p>“{“a”:1,”b”:2}”</p><h3 id="本地存储之Web-Storage"><a href="#本地存储之Web-Storage" class="headerlink" title="本地存储之Web Storage"></a>本地存储之Web Storage</h3><p>Web Storage又分为两种：<br>a. sessionStorage<br>b. localStorage</p><ol><li>区别<br>从字面意思就可以很清楚的看出来，sessionStorage将数据保存在session中，浏览器关闭也就没了；<br>而localStorage则一直将数据保存在客户端本地；<br>不管是sessionStorage，还是localStorage，可使用的API都相同，常用的有如下几个（以localStorage为例）：<br>保存数据：localStorage.setItem(key,value);<br>读取数据：localStorage.getItem(key);<br>删除单个数据：localStorage.removeItem(key);<br>删除所有数据：localStorage.clear();<br>得到某个索引的key：localStorage.key(index);<br>如上，key和value都必须为字符串，换言之，web Storage的API只能操作字符串。<br>2.localStorage 存储 数组<br>把数组（json对象）转化为 对象（字符串）即可 JSON.stringify()<!-- //保存 --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str = JSON.stringify(data.list);</span><br><span class="line">localStorage.setItem(&quot;options&quot;,str);</span><br></pre></td></tr></table></figure></li></ol><!-- //得到 --><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var optionss=localStorage.getItem(&quot;options&quot;);  </span><br><span class="line">console.log(JSON.parse(optionss));</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;DOM3-级事件中定义了9个鼠标事件&quot;&gt;&lt;a href=&quot;#DOM3-级事件中定义了9个鼠标事件&quot; class=&quot;headerlink&quot; title=&quot;DOM3 级事件中定义了9个鼠标事件&quot;&gt;&lt;/a&gt;DOM3 级事件中定义了9个鼠标事件&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="js事件" scheme="http://LeilaBlog.site/categories/js%E4%BA%8B%E4%BB%B6/"/>
    
    
      <category term="mouse  event" scheme="http://LeilaBlog.site/tags/mouse-event/"/>
    
  </entry>
  
  <entry>
    <title>scss使用</title>
    <link href="http://LeilaBlog.site/2017/11/06/scss%E4%BD%BF%E7%94%A8/"/>
    <id>http://LeilaBlog.site/2017/11/06/scss使用/</id>
    <published>2017-11-06T08:40:19.000Z</published>
    <updated>2017-11-06T10:08:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>为了有效的维护和开发项目，代码的重复利用就显得尤为重要。<br>在Sass中，@import @extend @mixin @include<br>可使代码更加具有重复利用性并简化你的代码</p><h3 id="介绍四项"><a href="#介绍四项" class="headerlink" title="介绍四项"></a>介绍四项</h3><ol><li><p>@import 是在引进外部的另一个.css 或者.scss 文件的时候用（我们外面有一个vars.scss的文件）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import &apos;vars&apos;;</span><br></pre></td></tr></table></figure></li><li><p>@extend(嵌套)指令通过继承从而简化了代码，但是它也有缺陷之处，首先是不够灵活，其次它还会将你不需要的其他地方具有相同类名的样式都继承过来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.error &#123;</span><br><span class="line">  border: 1px #f00;</span><br><span class="line">  background-color: #fdd;</span><br><span class="line">&#125;</span><br><span class="line">.specialerror &#123;</span><br><span class="line">  @extend .error;</span><br><span class="line">  border-width: 3px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>被编译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.error, .specialerror &#123;</span><br><span class="line">  border: 1px #f00;</span><br><span class="line">  background-color: #fdd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.specialerror &#123;</span><br><span class="line">  border-width: 3px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="3"><li>@mixin指令（混合宏）是另一种简化代码的方法。Mixin可以包含任意内容且可以传递参数，因此比‘@extend’更加灵活和强大。<br>个人理解他相当于定义一个样式  可以在其他地方引用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@mixin button &#123; </span><br><span class="line">    font-size: 1em; </span><br><span class="line">    padding: 0.5em 1.0em; </span><br><span class="line">    text-decoration: none; </span><br><span class="line">    color: #fff; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@mixin link &#123; </span><br><span class="line">    a &#123; </span><br><span class="line">        color: blue; </span><br><span class="line">        &amp;:visited &#123; </span><br><span class="line">            color: purple; </span><br><span class="line">        &#125; </span><br><span class="line">        &amp;:hover &#123; </span><br><span class="line">            color: white; </span><br><span class="line">        &#125; </span><br><span class="line">        &amp;:active &#123; </span><br><span class="line">            color: red; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在模块内你可以添加任何你想重复使用的样式<br>3-1. 在mixin模块的定义中还可以包含其他的mixin。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@mixin button-blue &#123;  </span><br><span class="line">    @include button;  </span><br><span class="line">    @include link;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>往后我们就可以引用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.aaa&#123;</span><br><span class="line">  @include button-blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种通过以包含多种简单mixin模块的方式创建较为复杂的mixin模块，而后@include来使用</p><ol start="4"><li>@include  调用@mixin指令所定义的样式 通过@include来调用 具有相同名称的mixin模块 eg：@mixin button 然后 @include 也是button就引进button的样式啦<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.button-green &#123; </span><br><span class="line">    @include button; </span><br><span class="line">    background-color: green; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>解析出来的css里面就会包含有@mixin button中定义的样式<br>生成的css如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.button-green &#123; </span><br><span class="line">    font-size: 1em; </span><br><span class="line">    padding: 0.5em 1.0em; </span><br><span class="line">    text-decoration: none; </span><br><span class="line">    color: #fff; </span><br><span class="line">    background-color: green; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="5"><li>Mixin模块包含选择器和规则集，也就是mixin包含的内容本身就是有效的CSS样式时，他们就可以在其他规则集外被调用。比如之前的@mixin link的模块<br>可以直接调用这个模块，即使不在一个选择器内。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@include link;</span><br></pre></td></tr></table></figure></li></ol><p>这段代码将会被解析为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a &#123;  </span><br><span class="line">    color: blue;</span><br><span class="line"></span><br><span class="line">    &amp;:visited &#123;</span><br><span class="line">        color: purple;</span><br><span class="line">    &#125;  </span><br><span class="line">    &amp;:hover &#123;</span><br><span class="line">        color: white;</span><br><span class="line">    &#125;  </span><br><span class="line">    &amp;:active &#123;</span><br><span class="line">        color: red;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之所以能这样调用是因为此mixin模块内既包含了选择器也包含了样式，如果没有选择器，那么编译后将不会有内容显示。<br>比如我们在选择器外直接调用button这个mixin模块（此模块只有样式但没有选择器），那么将不会有东西被编译。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@mixin button &#123;  </span><br><span class="line">    font-size: 1em;  </span><br><span class="line">    padding: 0.5em 1.0em;  </span><br><span class="line">    text-decoration: none;  </span><br><span class="line">    color: #fff;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@include button;</span><br></pre></td></tr></table></figure><p>不会被编译是因为你的样式没有被应用到任何元素上(即没有选择器)。</p><h3 id="参数的使用"><a href="#参数的使用" class="headerlink" title="参数的使用"></a>参数的使用</h3><ol><li>Mixin可以接收和使用参数，这使得它比@extend更加强大和灵活<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@mixin button($background) &#123;  </span><br><span class="line">    font-size: 1em;  </span><br><span class="line">    padding: 0.5em 1.0em;  </span><br><span class="line">    text-decoration: none;  </span><br><span class="line">    color: #fff;  </span><br><span class="line">    background: $background;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>注意到参数被设置为一个变量并成为backround属性的值。如果我们想创建一个绿色的按钮，那么就可以使用以下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.button-green &#123;  </span><br><span class="line">    @include button(green);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译出来后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.button-green &#123;</span><br><span class="line">    font-size: 1em;</span><br><span class="line">    padding: 0.5em 1.0em; </span><br><span class="line">    text-decoration: none; </span><br><span class="line">    color: #fff; </span><br><span class="line">    background: green; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>还可以在@mixin和@include中传递多个参数，参数间用逗号隔开。比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@mixin button($background, $color) &#123;  </span><br><span class="line">    font-size: 1em;  </span><br><span class="line">    padding: 0.5em 1.0em;  </span><br><span class="line">    text-decoration: none;  </span><br><span class="line">    color: $color;  </span><br><span class="line">    background: $background;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.button-green &#123;  </span><br><span class="line">    @include button(green, #fff);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="给参数设置默认值"><a href="#给参数设置默认值" class="headerlink" title="给参数设置默认值"></a>给参数设置默认值</h3><p>@mixin button($background: green) {<br>    font-size: 1em;<br>    padding: 0.5em 1.0em;<br>    text-decoration: none;<br>    color: #fff;<br>    background: $background;<br>}<br>现在如果你在调用的时候忘记传递参数值</p><p>.button-green {<br>    @include button;<br>}<br>你的代码将会使用你设置的参数默认值来解析，在这个例子中也就是green这个值。</p><p>.button-green {<br>    font-size: 1em;<br>    padding: 0.5em 1.0em;<br>    text-decoration: none;<br>    color: #fff;<br>    background: green;<br>}<br>/<em> 当然，你也可以通过提供一个参数值来覆盖这个默认值。</em>/ 这就是灵活性</p><p>.button-blue {<br>    @include button(blue);<br>}<br>这时将会使用你提供的值来编译代码</p><p>.button-blue {<br>    font-size: 1em;<br>    padding: 0.5em 1.0em;<br>    text-decoration: none;<br>    color: #fff;<br>    background: blue;<br>}</p><h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>a. 为了帮助你的代码更加容易理解，你可以在传递值给mixin时将参数名称和参数值一并传递过去。<br>1.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.button-green &#123;  </span><br><span class="line">    @include button($background: green, $color: #fff);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或者<br>2.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.button-green &#123;  </span><br><span class="line">    @include button(green, #fff);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关键字参数会额外增加一些代码，但是这会使得你的@include更加容易理解。比如，上面那段1.代码就比下面2.这段代码更加容易理解，因为上面的代码明确指出了green和#fff分别是什么。</p><p>虽然选择器的名称给了我们一些线索，可以大概推断出第一个参数代表什么，但是对于第二个参数却没有任何提示作用，而且一年后你很可能不会再记得这个参数的含义。</p><p>b. 一起传递关键字名称和值也被称为命名参数，这就使得你也可以以任意顺序传递命名参数。下面两种传递方式解析后会得到相同的结果。（不写参数名称只写参数值就不可以任意顺序）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.button-green &#123;  </span><br><span class="line">    @include button($background: green, $color: #fff);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.button-green &#123;  </span><br><span class="line">    @include button($color: #fff, $background: green);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="数量可变的参数"><a href="#数量可变的参数" class="headerlink" title="数量可变的参数"></a>数量可变的参数</h3><ol><li>Mixin可以接收未知数量的参数。比如你可以给同一个元素增加多种box-shadows。这里，我增加了暗灰和浅灰两种阴影。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;  </span><br><span class="line">    box-shadow: 0px 1px 2px #333,  </span><br><span class="line">                2px 3px 4px #ccc;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>在另一个元素上你可能只想使用一种阴影或者在其他元素上你又想使用三种或者四种阴影。这个时候你就可以创建一个接收数量可变的参数的mixin模块，并且在使用@include指令的时候决定传递参数的数量。<br>$shadow是变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@mixin box-shadows($shadow...) &#123;  </span><br><span class="line">    box-shadow: $shadow;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.container &#123;  </span><br><span class="line">    @include box-shadows(0px 1px 2px #333, 2px 3px 4px #ccc);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过在变量名后增加三个点（…）来使mixin模块接收数量可变的参数。需要注意的是这些是三个周期的字符，而不是单一的省略号。当你使用@include传递参数的时候，使用逗号将参数分开。</p><p>之前的代码将被编译为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;  </span><br><span class="line">    box-shadow: 0px 1px 2px #333,  </span><br><span class="line">                2px 3px 4px #ccc;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ol start="2"><li>同样可以给mixin传递可变的参数</li></ol><p>@mixin box-shadows($shadow…) {<br>    box-shadow: $shadow;<br>}</p><p>$shadows: 0px 1px 2px #333, 2px 3px 4px #ccc;</p><p>.container {<br>    @include box-shadows($shadows…);<br>}<br>这里我将变量’$shadows’设置为有两种阴影的list，并在@include中将其作为参数传递。同样，你也可以将参数设置为一个map，并且作为参数传递。你也可以同时传递list和map，只要list作为第一个传递。</p><p>@include box-shadows($list…, $map…)<br>我将在之后的系列具体谈论这一部分。</p><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>Mixins是一个在提高代码重复使用率方面非常有用的指令。而且能够使用和传递参数这一点使得它非常的强大著作权归作者所有。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了有效的维护和开发项目，代码的重复利用就显得尤为重要。&lt;br&gt;在Sass中，@import @extend @mixin @include&lt;br&gt;可使代码更加具有重复利用性并简化你的代码&lt;/p&gt;
&lt;h3 id=&quot;介绍四项&quot;&gt;&lt;a href=&quot;#介绍四项&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="css scss" scheme="http://LeilaBlog.site/tags/css-scss/"/>
    
  </entry>
  
  <entry>
    <title>CSS 属性 calc()</title>
    <link href="http://LeilaBlog.site/2017/11/06/CSS-%E5%B1%9E%E6%80%A7-calc/"/>
    <id>http://LeilaBlog.site/2017/11/06/CSS-属性-calc/</id>
    <published>2017-11-06T08:12:59.000Z</published>
    <updated>2017-11-06T10:32:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>预处理可以实现逻辑运算。但是预处理器只能同单位的运算，如角度单位，时间单位，频率单位，分辨率单元和固定长度单位。/<em> 而calc()可以实现混合单位的逻辑运算。</em>/<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">div &#123;</span><br><span class="line">   font-size: calc(3em + 5px);</span><br><span class="line">   padding: calc(1vmax + -1vmin);</span><br><span class="line">   transform: rotate(calc(1turn - 32deg));</span><br><span class="line">   background: hsl(180, calc(2*25%), 65%); </span><br><span class="line">   line-height: calc(8/3);</span><br><span class="line">   width: calc(23vmin - 2*3rem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在一些情况下，我们可能需要在calc()函数里传变量。这个在主流的预处理器可以实现。</p><p>首先，用 Sass，我们就像任何其他原生的CSS功能一样，插入变量：</p><p>$a: 4em<br>height: calc(#{$a} + 7px)<br>LESS写法如下：</p><p>@a: 4em;<br>height: ~”calc(@{a} + 7px)”;<br>还有Stylus：</p><p>a = 4em<br>height: “calc(%s + 7px)” % a<br>我们也可以使用原生的CSS变量，但要注意的是，只有在Firefox 31+支持，其他的浏览器暂时还不支持CSS的变量呢。</p><p>–a: 4em;<br>height: calc(var(–a) + 7px);<br>为了能够使得calc()函数正常的起作用，有以下几点要注意的事情。首先，除以零显然是行不通的。函数名和括号之间不可有空格。加号和减号运算符之间必须用空格分隔。</p><p>下面是几种错误的写法：</p><p>calc(50% / 0)<br>calc (1em + 7px)<br>calc(2rem+2vmin)<br>calc(2vw-2vh)</p><p>calc()函数的参数必须是数字，有或无指定单位，都是可以的。虽然基本的支持是非常好的，但是我们可能还是会遇到一些麻烦。接下来让我们看几个例子，看下有哪些兼容性问题，以及是否是最佳的解决方案。</p><h3 id="进一步了解运算属性"><a href="#进一步了解运算属性" class="headerlink" title="进一步了解运算属性"></a>进一步了解运算属性</h3><p>实现一个彩虹渐变。<br><a href="https://codepen.io/thebabydino/pen/VLOWaX" target="_blank" rel="noopener">例子链接</a><br>background: linear-gradient(#f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00);<br>1<br>但是，这些十六进制值看着不易理解。如果使用HSL()和calc()，就会更清晰些：</p><p>background: linear-gradient(hsl(calc(0<em>60), 100%, 50%),<br>                            hsl(calc(1</em>60), 100%, 50%),<br>                            hsl(calc(2<em>60), 100%, 50%),<br>                            hsl(calc(3</em>60), 100%, 50%),<br>                            hsl(calc(4<em>60), 100%, 50%),<br>                            hsl(calc(5</em>60), 100%, 50%),<br>                            hsl(calc(6*60), 100%, 50%));</p><p>可悲的是，在Firefox或Internet Explorer（IE）下，HSL() ，RGB()，HSLA()或RGBA()里使用calc()不起作用。也就是说demo只在WebKit浏览器下运行。因此，在实践中，在这一点上，最好让预处理来执行运算。而且使用预处理还有一个优点是，循环生成列表：</p><p>$n: 6;<br>$l: ();</p><p>@for $i from 0 through $n {<br>   $l: append($l, hsl($i*360/$n, 100%, 50%), comma);<br>}<br>background: linear-gradient($l);</p><h3 id="为弹性元素添加渐变背景色"><a href="#为弹性元素添加渐变背景色" class="headerlink" title="为弹性元素添加渐变背景色"></a>为弹性元素添加渐变背景色</h3><p>比方说，我们希望背景上顶部和底部有固定的1em的条纹。唯一的问题是我们不知道元素的高度。一种解决办法是使用两个渐变：</p><p>background:<br>   linear-gradient(#e53b2c 1em, transparent 1em),<br>   linear-gradient(0deg, #e53b2c 1em, #f9f9f9 1em);</p><p>但是，如果我们使用calc()就只需要一个渐变 就能搞定：</p><p>background:<br>   linear-gradient(#e53b2c 1em, #f9f9f9 1em, </p><pre><code>#f9f9f9 calc(100% - 1em), #e53b2c calc(100% - 1em));</code></pre><p>这种写法在所有支持calc()和渐变的浏览器里都可以工作正常，因为涉及的混合单位，它和预处理器的逻辑运算是不能等效的。另外，我们可以通过定义变量使其更易于维护：</p><p>$s: 1em;<br>$c: #e53b2c;<br>$bg: #f9f9f9;</p><p>background:<br>   linear-gradient($c $s,<br>                   $bg $s,<br>                   $bg calc(100% - #{$s}),<br>                   $c calc(100% - #{$s}));<br>注：出于一些原因，在chrome和opera里，有一个条纹比另一条略微的模糊、细。</p><p>上面只是几个简单的例子,且学且研究calc()在css中的应用吧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;预处理可以实现逻辑运算。但是预处理器只能同单位的运算，如角度单位，时间单位，频率单位，分辨率单元和固定长度单位。/&lt;em&gt; 而calc()可
      
    
    </summary>
    
    
  </entry>
  
</feed>
